//! code is credit from https://github.com/aquova/chip8-book/tree/master/code/desktop

use std::env;
use std::fs::File;
use std::io::Read;
use std::str::FromStr;
use bitvec::prelude::*;

use alloy::network::{EthereumWallet, Network};
use alloy::primitives::U256;
use alloy::providers::ext::AnvilApi;
use alloy::providers::{Provider, ProviderBuilder};
use alloy::signers::local::PrivateKeySigner;
use alloy::sol;
use alloy::transports::http::reqwest::Url;
use alloy::transports::Transport;
use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::rect::Rect;
use sdl2::render::Canvas;
use sdl2::video::Window;
use Emu::EmuInstance;

const SCREEN_WIDTH: usize = 64;
const SCREEN_HEIGHT: usize = 32;
const SCALE: u32 = 15;
const WINDOW_WIDTH: u32 = (SCREEN_WIDTH as u32) * SCALE;
const WINDOW_HEIGHT: u32 = (SCREEN_HEIGHT as u32) * SCALE;
// const TICKS_PER_FRAME: usize = 5;

sol! {
    #[sol(rpc, bytecode="0x610a80604090815260f06080818152609060a081905260c081905260e0818152610100849052602061012081905260606101405261016081905261018081905260706101a0526101c085905260106101e08190526102008690526102208590526102408690526102608690526102808190526102a08690526102c08190526102e08690526103008490526103208490526103408690526103608190526103808190526103a08690526103c08590526103e08690526104008190526104208690526104408690526104608590526104808690526104a08490526104c08690526104e086905261050081905261052091909152610540869052610560959095526105808490526105a08290526105c08490526105e0829052610600849052610620849052610640829052610660849052610680949094526106a08390526106c08390526106e08190526107008390526107208190526107408190526107608490526107808190526107a08490526107c08190526107e08490526108008390526108208290526108408290526108608290526108808390526108a08490526108c08190526108e081905261090052610920929092526109408190526109608290526109808190526109a08290526109c08190526109e0819052610a00829052610a2052610a40819052610a608190526101f9906000906050610292565b5034801561020657600080fd5b506003805461ffff191661020017905560005b605081101561028c57600081605081106102355761023561033a565b602081049091015460ff601f9092166101000a900416600482611000811061025f5761025f61033a565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610219565b50610350565b6003830191839082156103155791602002820160005b838211156102e657835183826101000a81548160ff021916908360ff16021790555092602001926001016020816000010492830192600103026102a8565b80156103135782816101000a81549060ff02191690556001016020816000010492830192600103026102e6565b505b50610321929150610325565b5090565b5b808211156103215760008155600101610326565b634e487b7160e01b600052603260045260246000fd5b6129f78061035f6000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c8063997a40c0116100de578063ae344f8e11610097578063d19dc8b511610071578063d19dc8b514610343578063d2bf2e1c1461034f578063d826f88f14610373578063e781d8c51461037b57600080fd5b8063ae344f8e14610318578063c040622614610328578063cbc950191461033057600080fd5b8063997a40c0146102b45780639cba24bb146102c7578063a560ea3b146102df578063a72b6604146102f2578063a8b3ac7814610305578063a95c372d1461031057600080fd5b80637ef91424116101305780637ef914241461022957806380bc398e1461023e5780638153da0314610251578063825284fd146102645780638c41bd001461027757806392ddeea0146102a157600080fd5b8063074b6fac146101785780632f57e5f7146101825780633eaf5d9f146101b05780636398efc8146101b857806366050ab9146101e257806368ad83f114610208575b600080fd5b610180610387565b005b610180610190366004612576565b608d805461ffff909216620100000263ffff000019909216919091179055565b61018061040c565b6101cb6101c6366004612598565b610424565b60405160ff90911681526020015b60405180910390f35b6101806101f0366004612576565b608d805461ffff191661ffff92909216919091179055565b608d5462010000900461ffff165b60405161ffff90911681526020016101d9565b6102316104a6565b6040516101d991906125b1565b61018061024c3660046125e3565b6104e2565b61018061025f36600461263f565b610582565b61018061027236600461270f565b610664565b61018061028536600461273b565b6090805460ff9092166101000261ff0019909216919091179055565b6101806102af366004612756565b6106e8565b6101806102c2366004612779565b610771565b6102cf6107db565b60405190151581526020016101d9565b6101cb6102ed366004612598565b61083b565b610216610300366004612598565b6108a0565b60905460ff166101cb565b610216610922565b609054610100900460ff166101cb565b610180610a54565b61018061033e3660046125e3565b610b27565b608d5461ffff16610216565b61018061035d36600461273b565b6090805460ff191660ff92909216919091179055565b610180610ba2565b60035461ffff16610216565b60905460ff16156103c45760908054600191906000906103ab90849060ff166127b9565b92506101000a81548160ff021916908360ff1602179055505b609054610100900460ff161561040a57609080546001919082906103f1908290610100900460ff166127b9565b92506101000a81548160ff021916908360ff1602179055505b565b6000610416610922565b905061042181610d5c565b50565b600061100082106104765760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b60448201526064015b60405180910390fd5b600482611000811061048a5761048a6127d8565b602081049091015460ff601f9092166101000a90041692915050565b6104ae612540565b604080516101008101918290529060849060089082845b8154815260200190600101908083116104c5575050505050905090565b61080082106105295760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b604482015260640161046d565b801561055857600160ff83161b6084600884811c90811061054c5761054c6127d8565b01805490911790555050565b600160ff83161b196084600884811c908110610576576105766127d8565b01805490911690555050565b80516102009060009061059590836127ee565b90506110008111156105e95760405162461bcd60e51b815260206004820152601c60248201527f4461746120746f6f206c6172676520746f2066697420696e2052414d00000000604482015260640161046d565b815b8181101561065a57836105fe8483612801565b8151811061060e5761060e6127d8565b6020026020010151600360010182611000811061062d5761062d6127d8565b602091828204019190066101000a81548160ff021916908360ff16021790555080806001019150506105eb565b5050905160915550565b61100082106106af5760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b604482015260640161046d565b8060048361100081106106c4576106c46127d8565b602091828204019190066101000a81548160ff021916908360ff1602179055505050565b601082106107345760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b604482015260640161046d565b80608e8360108110610748576107486127d8565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055505050565b601060ff8316106107c45760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e64730000604482015260640161046d565b80608c60ff8416601081106106c4576106c46127d8565b6084546000901580156107ee5750608554155b80156107fa5750608654155b80156108065750608754155b80156108125750608854155b801561081e5750608954155b801561082a5750608a54155b80156108365750608b54155b905090565b60006010821061088d5760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e64730000604482015260640161046d565b608c826010811061048a5761048a6127d8565b6000601082106108ee5760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b604482015260640161046d565b608e8260108110610901576109016127d8565b601091828204019190066002029054906101000a900461ffff169050919050565b6003546000906110009061093b9061ffff166001612814565b61ffff161061098c5760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e6473000000604482015260640161046d565b60035460009060049061ffff1661100081106109aa576109aa6127d8565b602081049190910154600354601f9092166101000a900460ff1691506000906004906109db9061ffff166001612814565b61ffff1661100081106109f0576109f06127d8565b60208104919091015460038054601f9093166101000a90910460ff169250600884901b62ffff001683179160029190600090610a3190849061ffff16612814565b92506101000a81548161ffff021916908361ffff16021790555080935050505090565b609154610a975760405162461bcd60e51b8152602060048201526011602482015270050726f6772616d2073697a65206973203607c1b604482015260640161046d565b60005b60915481101561042157610ab1600161100061282e565b60035461ffff918216911610610b095760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e6473000000604482015260640161046d565b6000610b13610922565b9050610b1e81610d5c565b50600101610a9a565b60108210610b6b5760405162461bcd60e51b8152602060048201526011602482015270092dcecc2d8d2c840d6caf240d2dcc8caf607b1b604482015260640161046d565b80608f8360108110610b7f57610b7f6127d8565b602091828204019190066101000a81548160ff0219169083151502179055505050565b6003805461ffff191661020017905560005b6008811015610bdc57600060848260088110610bd257610bd26127d8565b0155600101610bb4565b5060005b6010811015610c2b576000608c8260108110610bfe57610bfe6127d8565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610be0565b50608d805463ffffffff1916905560005b6010811015610c8c576000608e8260108110610c5a57610c5a6127d8565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055508080600101915050610c3c565b5060005b6010811015610cda576000608f8260108110610cae57610cae6127d8565b602081049091018054921515601f9092166101000a91820260ff90920219909216179055600101610c90565b506090805461ffff1916905560005b60508110156104215760008160508110610d0557610d056127d8565b602081049091015460ff601f9092166101000a9004166004826110008110610d2f57610d2f6127d8565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610ce9565b8061ffff16600003610d6b5750565b600f600c82901c811690600883901c811690600484901c811690841683158015610d96575060ff8316155b8015610da557508160ff16600e145b8015610db2575060ff8116155b15610dea5760005b6008811015610de257600060848260088110610dd857610dd86127d8565b0155600101610dba565b505050505050565b60ff8416158015610dfc575060ff8316155b8015610e0b57508160ff16600e145b8015610e1a57508060ff16600e145b15610e4457610e276123a5565b6003805461ffff191661ffff929092169190911790555050505050565b8360ff16600103610e6b5750506003805461ffff1916610fff909416939093179092555050565b8360ff16600203610e8c57600354610fff861690610e279061ffff1661246b565b8360ff16600303610f0b5760ff808616908190608c90861660108110610eb457610eb46127d8565b602081049091015460ff601f9092166101000a90041603610de2576003805460029190600090610ee990849061ffff16612814565b92506101000a81548161ffff021916908361ffff160217905550505050505050565b8360ff16600403610f685760ff808616908190608c90861660108110610f3357610f336127d8565b602081049091015460ff601f9092166101000a90041614610de2576003805460029190600090610ee990849061ffff16612814565b8360ff166005148015610f7c575060ff8116155b1561101b57608c60ff831660108110610f9757610f976127d8565b602081049091015460ff601f9092166101000a9004811690608c90851660108110610fc457610fc46127d8565b602081049091015460ff601f9092166101000a90041603611014576003805460029190600090610ff990849061ffff16612814565b92506101000a81548161ffff021916908361ffff1602179055505b5050505050565b8360ff1660060361106b5760ff808616908190608c90861660108110611043576110436127d8565b602091828204019190066101000a81548160ff021916908360ff160217905550505050505050565b8360ff166007036110d65760ff808616908190608c90861660108110611093576110936127d8565b602091828204019190068282829054906101000a900460ff166110b69190612848565b92506101000a81548160ff021916908360ff160217905550505050505050565b8360ff1660081480156110ea575060ff8116155b1561115957608c60ff831660108110611105576111056127d8565b602081049091015460ff601f9092166101000a9004811690608c90851660108110611132576111326127d8565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050565b8360ff16600814801561116f57508060ff166001145b156111f057608c60ff83166010811061118a5761118a6127d8565b602081049091015460ff601f9092166101000a9004811690608c908516601081106111b7576111b76127d8565b602091828204019190068282829054906101000a900460ff161792506101000a81548160ff021916908360ff1602179055505050505050565b8360ff16600814801561120657508060ff166002145b1561128057608c60ff831660108110611221576112216127d8565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061124e5761124e6127d8565b602081049091018054601f9092166101000a80830490931660ff90811684029302199091169190911790555050505050565b8360ff16600814801561129657508060ff166003145b1561131057608c60ff8316601081106112b1576112b16127d8565b602081049091015460ff601f9092166101000a9004811690608c908516601081106112de576112de6127d8565b60208104909101805460ff601f9093166101000a80820484169094188316840292909302199092161790555050505050565b8360ff16600814801561132657508060ff166004145b156114005782826000608c60ff831660108110611345576113456127d8565b602081049091015460ff601f9092166101000a9004811690608c90851660108110611372576113726127d8565b6020810491909101546113919291601f166101000a900460ff16612814565b905060ff8161ffff16116113a65760006113a9565b60015b608c805460ff60781b1916600160781b60ff9384160217815582918516601081106113d6576113d66127d8565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050505050565b8360ff16600814801561141657508060ff166005145b15611514578282608c60ff821660108110611433576114336127d8565b602081049091015460ff601f9092166101000a9004811690608c90841660108110611460576114606127d8565b602081049091015460ff601f9092166101000a9004161015611483576000611486565b60015b608c805460ff60781b1916600160781b60ff93841602178155908216601081106114b2576114b26127d8565b602081049091015460ff601f9092166101000a9004811690608c908416601081106114df576114df6127d8565b60208104909101805460ff601f9093166101000a80820484169490940383168402929093021990921617905550505050505050565b8360ff16600814801561152a57508060ff166006145b156115bd5782608c60ff821660108110611546576115466127d8565b602081049190910154608c805460ff60781b19166001601f9094166101000a9092048316600160781b0291909117815560ff83166010811061158a5761158a6127d8565b60208104909101805460ff601f9093166101000a808204841690941c831684029290930219909216179055505050505050565b8360ff1660081480156115d357508060ff166007145b156116f5578282608c60ff8316601081106115f0576115f06127d8565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061161d5761161d6127d8565b602081049091015460ff601f9092166101000a9004161015611640576000611643565b60015b608c805460ff60781b1916600160781b60ff938416021781559083166010811061166f5761166f6127d8565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061169c5761169c6127d8565b602091828204019190069054906101000a900460ff160360036089018360ff16601081106116cc576116cc6127d8565b602091828204019190066101000a81548160ff021916908360ff16021790555050505050505050565b8360ff16600814801561170b57508060ff16600e145b156117a957826007608c60ff831660108110611729576117296127d8565b602081049190910154608c805460ff60781b1916601f9093166101000a90910460ff90811690931c6001908116600160781b029290921781559091831660108110611776576117766127d8565b60208104909101805460ff601f9093166101000a808204841690941b831684029290930219909216179055505050505050565b8360ff1660091480156117bd575060ff8116155b15611860578282608c60ff8216601081106117da576117da6127d8565b602081049091015460ff601f9092166101000a9004811690608c90841660108110611807576118076127d8565b602081049091015460ff601f9092166101000a9004161461185757600380546002919060009061183c90849061ffff16612814565b92506101000a81548161ffff021916908361ffff1602179055505b50505050505050565b8360ff16600a03611887575050608d805461ffff1916610fff909416939093179092555050565b8360ff16600b036118c757608c54610fff8616906118a990829060ff16612814565b6003805461ffff191661ffff92909216919091179055505050505050565b8360ff16600c0361195e578260ff86166000610100426118e8600143612801565b6003546040516119209392409161ffff1690602001928352602083019190915260f01b6001600160f01b031916604082015260420190565b6040516020818303038152906040528051906020012060001c6119439190612877565b9050818116608c60ff8516601081106113d6576113d66127d8565b8360ff16600d03611be15760006040608c60ff861660108110611983576119836127d8565b602091828204019190069054906101000a900460ff166119a3919061288b565b905060006020608c60ff8616601081106119bf576119bf6127d8565b602091828204019190069054906101000a900460ff166119df919061288b565b608c805460ff60781b1916905590508260005b8160ff168160ff161015611bd657608d54600090600490611a1b9060ff85169061ffff16612814565b61ffff166110008110611a3057611a306127d8565b602081049091015460ff601f9092166101000a900416905060005b60088160ff161015611bcc576000611a648260076127b9565b60ff168360ff16901c6001169050600060408389611a829190612848565b60ff16611a8f91906128ad565b61ffff16905060006020611aa3878a612848565b60ff16611ab091906128ad565b61ffff169050600082611ac46040846128d1565b611ace91906128f7565b90506000611ade61010083612913565b63ffffffff1690506000611af46101008461293b565b63ffffffff1690506000611b098260ff612801565b60848460088110611b1c57611b1c6127d8565b01546001911c8116158015925060ff8916909114821415908290611b3e575080155b15611b5757608c805460ff60781b1916600160781b1790555b8015611b8c57611b688360ff612801565b6001901b60848560088110611b7f57611b7f6127d8565b0180549091179055611bb8565b611b978360ff612801565b6001901b1960848560088110611baf57611baf6127d8565b01805490911690555b505060019096019550611a4b945050505050565b50506001016119f2565b505050505050505050565b8360ff16600e148015611bf757508160ff166009145b8015611c0657508060ff16600e145b15611cc557826000608c60ff831660108110611c2457611c246127d8565b602081049091015460ff601f9092166101000a900416905060108110611c7a5760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b604482015260640161046d565b608f60ff821660108110611c9057611c906127d8565b602081049091015460ff601f9092166101000a9004161561185757600380546002919060009061183c90849061ffff16612814565b8360ff16600e148015611cdb57508160ff16600a145b8015611cea57508060ff166001145b15611da857826000608c60ff831660108110611d0857611d086127d8565b602081049091015460ff601f9092166101000a900416905060108110611d5e5760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b604482015260640161046d565b608f60ff821660108110611d7457611d746127d8565b602081049091015460ff601f9092166101000a90041661185757600380546002919060009061183c90849061ffff16612814565b8360ff16600f148015611dbc575060ff8216155b8015611dcb57508060ff166007145b15611df057609054839060ff90811690608c90831660108110611043576110436127d8565b8360ff16600f148015611e04575060ff8216155b8015611e1357508060ff16600a145b15611ec257826000805b601060ff82161015611ea257608f60ff821660108110611e3f57611e3f6127d8565b602081049091015460ff601f9092166101000a90041615611e9a5780608c60ff851660108110611e7157611e716127d8565b602091828204019190066101000a81548160ff021916908360ff16021790555060019150611ea2565b600101611e1d565b508061185757600380546002919060009061183c90849061ffff1661282e565b8360ff16600f148015611ed857508160ff166001145b8015611ee757508060ff166005145b15611f305782608c60ff821660108110611f0357611f036127d8565b60208104909101546090805460ff191660ff601f9094166101000a90920492909216179055505050505050565b8360ff16600f148015611f4657508160ff166001145b8015611f5557508060ff166008145b15611fa55782608c60ff821660108110611f7157611f716127d8565b6020810491909101546090805461ff001916601f90931661010090810a90920460ff16909102919091179055505050505050565b8360ff16600f148015611fbb57508160ff166001145b8015611fca57508060ff16600e145b156120155782608c60ff821660108110611fe657611fe66127d8565b602081049190910154608d8054601f9093166101000a90910460ff1691600090610ee990849061ffff16612814565b8360ff16600f14801561202b57508160ff166002145b801561203a57508060ff166009145b1561209a57826000608c60ff831660108110612058576120586127d8565b602081049091015460ff601f9092166101000a900416905061207b816005612963565b608d805461ffff191661ffff9290921691909117905550505050505050565b8360ff16600f1480156120b057508160ff166003145b80156120bf57508060ff166003145b156121d457826000608c60ff8316601081106120dd576120dd6127d8565b602081049091015460ff601f9092166101000a9004169050612100606482612980565b608d5460049061ffff16611000811061211b5761211b6127d8565b602091828204019190066101000a81548160ff021916908360ff160217905550600a80826121499190612980565b612153919061288b565b608d546004906121689061ffff166001612814565b61ffff16611000811061217d5761217d6127d8565b602091828204019190066101000a81548160ff021916908360ff160217905550600a816121aa919061288b565b608d546004906121bf9061ffff166002612814565b61ffff1661100081106116cc576116cc6127d8565b8360ff16600f1480156121ea57508160ff166005145b80156121f957508060ff166005145b1561229c578260005b8160ff168160ff161161185757608c60ff821660108110612225576122256127d8565b6020810490910154608d5460ff601f9093166101000a9091048216916004916122549185169061ffff16612814565b61ffff166110008110612269576122696127d8565b602091828204019190066101000a81548160ff021916908360ff1602179055508080612294906129a2565b915050612202565b8360ff16600f1480156122b257508160ff166006145b80156122c157508060ff166005145b15612364578260005b8160ff168160ff161161185757608d546004906122ef9060ff84169061ffff16612814565b61ffff166110008110612304576123046127d8565b602081049091015460ff601f9092166101000a9004811690608c90831660108110612331576123316127d8565b602091828204019190066101000a81548160ff021916908360ff160217905550808061235c906129a2565b9150506122ca565b60405162461bcd60e51b815260206004820152601660248201527513dc18dbd919481b9bdd081a5b5c1b195b595b9d195960521b604482015260640161046d565b608d5460009062010000900461ffff166123f35760405162461bcd60e51b815260206004820152600f60248201526e537461636b20756e646572666c6f7760881b604482015260640161046d565b608d80546001919060029061241390849062010000900461ffff1661282e565b82546101009290920a61ffff818102199093169183160217909155608d54608e9250620100009004166010811061244c5761244c6127d8565b601091828204019190066002029054906101000a900461ffff16905090565b608d5460106201000090910461ffff16106124b95760405162461bcd60e51b815260206004820152600e60248201526d537461636b206f766572666c6f7760901b604482015260640161046d565b608d548190608e9062010000900461ffff16601081106124db576124db6127d8565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555060016003608a0160028282829054906101000a900461ffff166125239190612814565b92506101000a81548161ffff021916908361ffff16021790555050565b6040518061010001604052806008906020820280368337509192915050565b803561ffff8116811461257157600080fd5b919050565b60006020828403121561258857600080fd5b6125918261255f565b9392505050565b6000602082840312156125aa57600080fd5b5035919050565b6101008101818360005b60088110156125da5781518352602092830192909101906001016125bb565b50505092915050565b600080604083850312156125f657600080fd5b823591506020830135801515811461260d57600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b803560ff8116811461257157600080fd5b60006020828403121561265157600080fd5b813567ffffffffffffffff81111561266857600080fd5b8201601f8101841361267957600080fd5b803567ffffffffffffffff81111561269357612693612618565b8060051b604051601f19603f830116810181811067ffffffffffffffff821117156126c0576126c0612618565b6040529182526020818401810192908101878411156126de57600080fd5b6020850194505b83851015612704576126f68561262e565b8152602094850194016126e5565b509695505050505050565b6000806040838503121561272257600080fd5b823591506127326020840161262e565b90509250929050565b60006020828403121561274d57600080fd5b6125918261262e565b6000806040838503121561276957600080fd5b823591506127326020840161255f565b6000806040838503121561278c57600080fd5b6127958361262e565b91506127326020840161262e565b634e487b7160e01b600052601160045260246000fd5b60ff82811682821603908111156127d2576127d26127a3565b92915050565b634e487b7160e01b600052603260045260246000fd5b808201808211156127d2576127d26127a3565b818103818111156127d2576127d26127a3565b61ffff81811683821601908111156127d2576127d26127a3565b61ffff82811682821603908111156127d2576127d26127a3565b60ff81811683821601908111156127d2576127d26127a3565b634e487b7160e01b600052601260045260246000fd5b60008261288657612886612861565b500690565b600060ff83168061289e5761289e612861565b8060ff84160691505092915050565b600061ffff8316806128c1576128c1612861565b8061ffff84160691505092915050565b63ffffffff81811683821602908116908181146128f0576128f06127a3565b5092915050565b63ffffffff81811683821601908111156127d2576127d26127a3565b600063ffffffff83168061292957612929612861565b8063ffffffff84160491505092915050565b600063ffffffff83168061295157612951612861565b8063ffffffff84160691505092915050565b61ffff81811683821602908116908181146128f0576128f06127a3565b600060ff83168061299357612993612861565b8060ff84160491505092915050565b600060ff821660ff81036129b8576129b86127a3565b6001019291505056fea26469706673582212208ad717760df187194020091ca5ca13b8a4be776cf5193c9ea51a8293053ff62164736f6c634300081c0033")]
    contract Emu {
        // -------------------------------------------------------------------------
        // Constants
        // -------------------------------------------------------------------------
    
        /// @notice screen width 64 pixels
        uint16 constant SCREEN_WIDTH = 64;
        /// @notice screen height 32 pixels
        uint16 constant SCREEN_HEIGHT = 32;
    
        /// @notice size of RAM
        uint16 constant RAM_SIZE = 4096;
        /// @notice number of registers
        uint8 constant NUM_REGS = 16;
        /// @notice number of stack entries
        uint8 constant STACK_SIZE = 16;
        /// @notice number of keys
        uint8 constant NUM_KEYS = 16;
    
        // -------------------------------------------------------------------------
        // Display
        // -------------------------------------------------------------------------


        /// @notice fontset size
        uint8 constant FONTSET_SIZE = 80;

        /// @notice fontset
        /// @dev Most modern emulators will use that space to store the sprite data for font characters of all the
        /// hexadecimal digits, that is characters of 0-9 and A-F. We could store this data at any fixed position in RAM, but this
        /// space is already defined as empty anyway. Each character is made up of eight rows of five pixels, with each row using
        /// a byte of data, meaning that each letter altogether takes up five bytes of data. The following diagram illustrates how
        /// a character is stored as bytes
        uint8[80] FONTSET = [
            0xF0,
            0x90,
            0x90,
            0x90,
            0xF0, // 0
            0x20,
            0x60,
            0x20,
            0x20,
            0x70, // 1
            0xF0,
            0x10,
            0xF0,
            0x80,
            0xF0, // 2
            0xF0,
            0x10,
            0xF0,
            0x10,
            0xF0, // 3
            0x90,
            0x90,
            0xF0,
            0x10,
            0x10, // 4
            0xF0,
            0x80,
            0xF0,
            0x10,
            0xF0, // 5
            0xF0,
            0x80,
            0xF0,
            0x90,
            0xF0, // 6
            0xF0,
            0x10,
            0x20,
            0x40,
            0x40, // 7
            0xF0,
            0x90,
            0xF0,
            0x90,
            0xF0, // 8
            0xF0,
            0x90,
            0xF0,
            0x10,
            0xF0, // 9
            0xF0,
            0x90,
            0xF0,
            0x90,
            0x90, // A
            0xE0,
            0x90,
            0xE0,
            0x90,
            0xE0, // B
            0xF0,
            0x80,
            0x80,
            0x80,
            0xF0, // C
            0xE0,
            0x90,
            0x90,
            0x90,
            0xE0, // D
            0xF0,
            0x80,
            0xF0,
            0x80,
            0xF0, // E
            0xF0,
            0x80,
            0xF0,
            0x80,
            0x80 // F
        ];

    
        struct Emulator {
            /// @notice 16-bit program counter
            uint16 pc;
            /// @notice 4KB RAM
            uint8[4096] ram;
            /// @notice A 64x32 monochrome display = 2048 bit = 256 * 8 bits
            uint256[8] screen;
            /// @notice Sixteen 8-bit general purpose registers, referred to as V0 thru VF
            uint8[16] v_reg;
            /// @notice Single 16-bit register used as a pointer for memory access, called the I Register
            uint16 i_reg;
            /// @notice Stack pointer
            uint16 sp;
            /// @notice 16-bit stack used for calling and returning from subroutines
            uint16[16] stack;
            /// @notice 16-key keyboard input
            bool[16] keys;
            /// @notice Delay timer
            uint8 dt;
            /// @notice Sound timer
            uint8 st;
            /// @notice Program size
            uint256 program_size;
        }
    
        Emulator emu;
    
        // -------------------------------------------------------------------------
        // Initialization
        // -------------------------------------------------------------------------
    
        /// @notice start address for program (usually 0x200)
        uint16 constant START_ADDR = 0x200;
    
        constructor() {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        /// @notice Reset the emulator
        function reset() public {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < 8; i++) {
                emu.screen[i] = 0;
            }
            for (uint256 i = 0; i < NUM_REGS; i++) {
                emu.v_reg[i] = 0;
            }
            emu.i_reg = 0;
            emu.sp = 0;
            for (uint256 i = 0; i < STACK_SIZE; i++) {
                emu.stack[i] = 0;
            }
            for (uint256 i = 0; i < NUM_KEYS; i++) {
                emu.keys[i] = false;
            }
            emu.dt = 0;
            emu.st = 0;
             // Copy FONTSET
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        // -------------------------------------------------------------------------
        // Emulation functions
        // -------------------------------------------------------------------------
    
        /// @notice Push a value onto the stack
        function push(uint16 val) internal {
            require(emu.sp < STACK_SIZE, "Stack overflow");
            emu.stack[emu.sp] = val;
            emu.sp += 1;
        }
    
        /// @notice Pop a value from the stack
        function pop() internal returns (uint16) {
            require(emu.sp > 0, "Stack underflow");
            emu.sp -= 1;
            return emu.stack[emu.sp];
        }
    
        /// @notice CPU processing loop
        /// @dev This function is called once per tick of the CPU.
        /// Fetch the next instruction, decode and execute it.
        function tick() public {
            // Fetch
            uint16 op = fetch();
            // Decode & execute
            execute(op);
        }
    
        function tickTimers() public {
            if (emu.dt > 0) {
                emu.dt -= 1;
            }
    
            if (emu.st > 0) {
                if (emu.st == 1) {
                    // BEEP
                }
                emu.st -= 1;
            }
        }
    
        /// @notice Fetch the next instruction
        function fetch() public returns (uint16) {
            require(emu.pc + 1 < RAM_SIZE, "Program counter out of bounds");
            uint16 higher_byte = uint16(emu.ram[emu.pc]);
            uint16 lower_byte = uint16(emu.ram[emu.pc + 1]);
            uint16 op = (higher_byte << 8) | lower_byte;
            emu.pc += 2;
            return op;
        }
    
        function run() public {
            require(emu.program_size > 0, "Program size is 0");
            for (uint256 i = 0; i < emu.program_size; i++) {
                require(emu.pc < RAM_SIZE - 1, "Program counter out of bounds");
                // Fetch the opcode
                uint16 op = fetch();
                // Execute the opcode
                execute(op);
            }
        }
    
        function execute(uint16 op) internal {
            // 0000 - Nop - NOP
            if (op == 0x0000) return;
    
            uint8 digit1 = uint8((op & 0xF000) >> 12);
            uint8 digit2 = uint8((op & 0x0F00) >> 8);
            uint8 digit3 = uint8((op & 0x00F0) >> 4);
            uint8 digit4 = uint8(op & 0x000F);
    
            //  00E0 - CLS
            if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0) {
                for (uint256 i = 0; i < 8; i++) {
                    emu.screen[i] = 0;
                }
                return;
            }
            // 00EE - RET
            else if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0xE) {
                emu.pc = pop();
                return;
            }
            //  1NNN - JMP NNN
            else if (digit1 == 0x1) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = nnn;
                return;
            }
            //  2NNN - CALL NNN
            else if (digit1 == 0x2) {
                uint16 nnn = op & 0x0FFF;
                push(emu.pc);
                emu.pc = nnn;
                return;
            }
            //  3NNN - SKIP VX == NN
            else if (digit1 == 0x3) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] == nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  4NNN - SKIP VX != NN
            else if (digit1 == 0x4) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] != nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  5NNN - SKIP VX == VY
            else if (digit1 == 0x5 && digit4 == 0x0) {
                if (emu.v_reg[digit2] == emu.v_reg[digit3]) {
                    emu.pc += 2;
                }
                return;
            }
            //  6NNN - VX = NN
            else if (digit1 == 0x6) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] = nn;
                return;
            }
            //  7NNN - VX += NN
            else if (digit1 == 0x7) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] += nn;
                return;
            }
            // 8XY0 - VX = VY
            else if (digit1 == 0x8 && digit4 == 0x0) {
                emu.v_reg[digit2] = emu.v_reg[digit3];
                return;
            }
            // 8XY1 - VX |= VY
            else if (digit1 == 0x8 && digit4 == 0x1) {
                emu.v_reg[digit2] |= emu.v_reg[digit3];
                return;
            }
            // 8XY2 - VX &= VY
            else if (digit1 == 0x8 && digit4 == 0x2) {
                emu.v_reg[digit2] &= emu.v_reg[digit3];
                return;
            }
            // 8XY3 - VX ^= VY
            else if (digit1 == 0x8 && digit4 == 0x3) {
                emu.v_reg[digit2] ^= emu.v_reg[digit3];
                return;
            }
            // 8XY4 - VX += VY (with carry)
            else if (digit1 == 0x8 && digit4 == 0x4) {
                uint8 x = digit2;
                uint8 y = digit3;
                uint16 sum = uint16(emu.v_reg[x]) + uint16(emu.v_reg[y]);
                emu.v_reg[0xF] = sum > 0xFF ? 1 : 0;
                emu.v_reg[x] = uint8(sum);
                return;
            }
            // 8XY5 - VX -= VY (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x5) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[x] >= emu.v_reg[y] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] -= emu.v_reg[y];
                }
                return;
            }
            // 8XY6 - VX >>= 1
            else if (digit1 == 0x8 && digit4 == 0x6) {
                uint8 x = digit2;
                emu.v_reg[0xF] = emu.v_reg[x] & 0x1;
                emu.v_reg[x] >>= 1;
                return;
            }
            // 8XY7 - VX = VY - VX (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x7) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[y] >= emu.v_reg[x] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] = emu.v_reg[y] - emu.v_reg[x];
                }
                return;
            }
            // 8XYE - VX <<= 1
            else if (digit1 == 0x8 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.v_reg[0xF] = (emu.v_reg[x] >> 7) & 0x1;
                emu.v_reg[x] <<= 1;
                return;
            }
            // 9XY0 - SKIP VX != VY
            else if (digit1 == 0x9 && digit4 == 0x0) {
                uint8 x = digit2;
                uint8 y = digit3;
                if (emu.v_reg[x] != emu.v_reg[y]) {
                    emu.pc += 2;
                }
                return;
            }
            // ANNN - I = NNN
            else if (digit1 == 0xA) {
                uint16 nnn = op & 0x0FFF;
                emu.i_reg = nnn;
                return;
            }
            // BNNN - PC = V0 + NNN
            else if (digit1 == 0xB) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = uint16(emu.v_reg[0]) + nnn;
                return;
            }
            // CXNN - VX = rand() & NN
            else if (digit1 == 0xC) {
                uint8 x = digit2;
                uint8 nn = uint8(op & 0x00FF);
                // Pseudo-random number generation (not secure)
                uint8 rand =
                    uint8(uint256(keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 1), emu.pc))) % 256);
                emu.v_reg[x] = rand & nn;
                return;
            }
            // DXYN - DRAW
            else if (digit1 == 0xD) {
                uint8 x = emu.v_reg[digit2] % uint8(SCREEN_WIDTH);
                uint8 y = emu.v_reg[digit3] % uint8(SCREEN_HEIGHT);
                uint8 height = digit4;
                emu.v_reg[0xF] = 0; // Reset VF
    
                for (uint8 row = 0; row < height; row++) {
                    uint8 sprite_byte = emu.ram[emu.i_reg + row];
                    for (uint8 col = 0; col < 8; col++) {
                        // Get the sprite pixel (bit) at the current column
                        uint8 sprite_pixel = (sprite_byte >> (7 - col)) & 0x1;
    
                        // Calculate the screen coordinates, wrapping around if necessary
                        uint32 screen_x = uint32((x + col) % SCREEN_WIDTH);
                        uint32 screen_y = uint32((y + row) % SCREEN_HEIGHT);
    
                        // Calculate the index in the display buffer
                        uint32 pixel_index = screen_y * SCREEN_WIDTH + screen_x; // Range: 0 to 2047
    
                        // Calculate the display array index and bit position
                        uint256 display_index = pixel_index / 256; // Index in emu.screen[]
                        uint256 bit_position = pixel_index % 256; // Bit position within emu.screen[display_index]
    
                        // Get the current pixel value from the display
                        bool pixel_before = ((emu.screen[display_index] >> (255 - bit_position)) & 0x1) != 0;
    
                        // Calculate the new pixel value using XOR (as per CHIP-8 drawing behavior)
                        bool new_pixel = pixel_before != (sprite_pixel == 1);
    
                        // Update the collision flag VF if a pixel is erased
                        if (pixel_before && !new_pixel) {
                            emu.v_reg[0xF] = 1;
                        }
    
                        // Update the display with the new pixel value
                        if (new_pixel) {
                            // Set the bit to 1
                            emu.screen[display_index] |= (1 << (255 - bit_position));
                        } else {
                            // Set the bit to 0
                            emu.screen[display_index] &= ~(1 << (255 - bit_position));
                        }
                    }
                }
                return;
            }
            // EX9E - SKIP if key[VX] pressed
            else if (digit1 == 0xE && digit3 == 0x9 && digit4 == 0xE) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if (emu.keys[key]) {
                    emu.pc += 2;
                }
                return;
            }
            // EXA1 - SKIP if key[VX] not pressed
            else if (digit1 == 0xE && digit3 == 0xA && digit4 == 0x1) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if (!emu.keys[key]) {
                    emu.pc += 2;
                }
                return;
            }
            // FX07 - VX = DT
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0x7) {
                uint8 x = digit2;
                emu.v_reg[x] = emu.dt;
                return;
            }
            // FX0A - Wait for key press
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0xA) {
                uint8 x = digit2;
                bool key_pressed = false;
                for (uint8 i = 0; i < NUM_KEYS; i++) {
                    if (emu.keys[i]) {
                        emu.v_reg[x] = i;
                        key_pressed = true;
                        break;
                    }
                }
                if (!key_pressed) {
                    // Repeat this opcode
                    emu.pc -= 2;
                }
                return;
            }
            // FX15 - DT = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x5) {
                uint8 x = digit2;
                emu.dt = emu.v_reg[x];
                return;
            }
            // FX18 - ST = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x8) {
                uint8 x = digit2;
                emu.st = emu.v_reg[x];
                return;
            }
            // FX1E - I += VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.i_reg += uint16(emu.v_reg[x]);
                return;
            }
            // FX29 - I = location of sprite for digit VX
            else if (digit1 == 0xF && digit3 == 0x2 && digit4 == 0x9) {
                uint8 x = digit2;
                uint8 digit = emu.v_reg[x];
                emu.i_reg = uint16(digit) * 5; // Each sprite is 5 bytes
                return;
            }
            // FX33 - Store BCD representation of VX in memory locations I, I+1, and I+2
            else if (digit1 == 0xF && digit3 == 0x3 && digit4 == 0x3) {
                uint8 x = digit2;
                uint8 value = emu.v_reg[x];
                emu.ram[emu.i_reg] = value / 100;
                emu.ram[emu.i_reg + 1] = (value / 10) % 10;
                emu.ram[emu.i_reg + 2] = value % 10;
                return;
            }
            // FX55 - Store V0 to VX in memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x5 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.ram[emu.i_reg + i] = emu.v_reg[i];
                }
                return;
            }
            // FX65 - Read V0 to VX from memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x6 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.v_reg[i] = emu.ram[emu.i_reg + i];
                }
                return;
            } else {
                revert("Opcode not implemented");
            }
        }
    
        // -------------------------------------------------------------------------
        // Frontend functions
        // -------------------------------------------------------------------------
    
        /// @notice Get display
        function getDisplay() public view returns (uint256[8] memory) {
            return emu.screen;
        }
    
        /// @notice Handle keypress event
        function keypress(uint256 idx, bool pressed) public {
            require(idx < NUM_KEYS, "Invalid key index");
            emu.keys[idx] = pressed;
        }
    
        /// @notice Load program into memory
        function load(uint8[] memory data) public {
            uint256 start = START_ADDR;
            uint256 end = START_ADDR + data.length;
            require(end <= RAM_SIZE, "Data too large to fit in RAM");
            for (uint256 i = start; i < end; i++) {
                emu.ram[i] = data[i - start];
            }
            emu.program_size = data.length;
        }
    
        // -------------------------------------------------------------------------
        // Utility functions
        // -------------------------------------------------------------------------
    
        function getPC() public view returns (uint16) {
            return emu.pc;
        }
    
        function getRAMValueAt(uint256 index) public view returns (uint8) {
            require(index < RAM_SIZE, "RAM index out of bounds");
            return emu.ram[index];
        }
    
        function getVRegister(uint256 index) public view returns (uint8) {
            require(index < NUM_REGS, "V register index out of bounds");
            return emu.v_reg[index];
        }
    
        function setVRegister(uint8 index, uint8 value) public {
            require(index < NUM_REGS, "V register index out of bounds");
            emu.v_reg[index] = value;
        }
    
        function getIRegister() public view returns (uint16) {
            return emu.i_reg;
        }
    
        function setIRegister(uint16 value) public {
            emu.i_reg = value;
        }
    
        function setRAMValueAt(uint256 index, uint8 value) public {
            require(index < RAM_SIZE, "RAM index out of bounds");
            emu.ram[index] = value;
        }
    
        function getDelayTimer() public view returns (uint8) {
            return emu.dt;
        }
    
        function setDelayTimer(uint8 value) public {
            emu.dt = value;
        }
    
        function getSoundTimer() public view returns (uint8) {
            return emu.st;
        }
    
        function setSoundTimer(uint8 value) public {
            emu.st = value;
        }
    
        function getSP() public view returns (uint16) {
            return emu.sp;
        }
    
        function getStackValue(uint256 index) public view returns (uint16) {
            require(index < STACK_SIZE, "Stack index out of bounds");
            return emu.stack[index];
        }
    
        function setStackValue(uint256 index, uint16 value) public {
            require(index < STACK_SIZE, "Stack index out of bounds");
            emu.stack[index] = value;
        }
    
        function setSP(uint16 value) public {
            emu.sp = value;
        }
    
        function setScreenPixel(uint256 index, bool value) public {
            unchecked {
                require(index < SCREEN_WIDTH * SCREEN_HEIGHT, "Index out of bounds");
                if (value) {
                    // Set the bit to 1
                    emu.screen[index >> 8] |= 1 << (index & 255);
                } else {
                    // Set the bit to 0
                    emu.screen[index >> 8] &= ~(1 << (index & 255));
                }
            }
        }
    
        function isDisplayCleared() public view returns (bool) {
            return (
                emu.screen[0] == 0 && emu.screen[1] == 0 && emu.screen[2] == 0 && emu.screen[3] == 0 && emu.screen[4] == 0
                    && emu.screen[5] == 0 && emu.screen[6] == 0 && emu.screen[7] == 0
            );
        }
    }    
}

#[tokio::main]
async fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: cargo run path/to/game");
        return;
    }

    // Setup SDL
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let window = video_subsystem
        .window("Chip-8 Emulator", WINDOW_WIDTH, WINDOW_HEIGHT)
        .position_centered()
        .opengl()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    canvas.clear();
    canvas.present();
    let mut event_pump = sdl_context.event_pump().unwrap();
    // testing anvil account
    let signer: PrivateKeySigner = PrivateKeySigner::from_str(
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    )
    .unwrap();
    let wallet = EthereumWallet::from(signer);

    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(Url::from_str("http://localhost:8545").unwrap());

    // Get node info using the Anvil API.
    let info = provider.anvil_node_info().await.unwrap();

    println!("Node info: {:#?}", info);

    let chip8 = Emu::deploy(&provider).await.unwrap();
    // commented out, address that deployed on sepolia
    // let address = Address::from_str("0x8494dba7A8958629fE3e55D8F7F5eAF22978a467").unwrap();
    // let chip8 = Emu::new(address, &provider);

    let mut rom = File::open(&args[1]).expect("Unable to open file");
    let mut buffer = Vec::new();

    rom.read_to_end(&mut buffer).unwrap();
    println!("Loaded ROM with {:?} bytes", buffer);
    let builder = chip8.load(buffer.to_vec());
    builder.call().await.unwrap();
    // 250ms
    let tx = builder.send().await.unwrap().get_receipt().await.unwrap();
    println!("load tx: {:?}", tx);
    let r = chip8.getRAMValueAt(U256::from(512)).call().await.unwrap();
    // Check loaded successfully
    assert_eq!(r._0, buffer[0]);

    'gameloop: loop {
        let now = std::time::Instant::now();
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::Escape),
                    ..
                } => {
                    break 'gameloop;
                }
                Event::KeyDown {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), true);
                        builder.call().await.unwrap();

                        let tx = builder.send().await.unwrap();
                        println!("⭐️ key {:?} down tx: {:?}", key, tx);
                    }
                }
                Event::KeyUp {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), false);
                        builder.call().await.unwrap();

                        let tx = builder.send().await.unwrap();
                        println!("⭐️ key {:?} up tx: {:?}", key, tx);
                    }
                }
                _ => (),
            }
        }

        // TODO: I want to have tick per frame
        // for _ in 0..TICKS_PER_FRAME {}
        let builder = chip8.tick();
        builder.call().await.unwrap();
        // 250ms
        let tx = builder.send().await.unwrap().get_receipt().await.unwrap();
        println!("tx:{:?}", tx);

        let pc = chip8.getPC().call().await.unwrap();
        println!("PC: {:?}", pc._0);
        chip8.tickTimers().call().await.unwrap();
        draw_screen(&chip8, &mut canvas).await;

        let end = std::time::Instant::now();
        println!("⌛️ duration :{:?}", end.duration_since(now));
    }
}

async fn draw_screen<T, P, N>(emu: &EmuInstance<T, P, N>, canvas: &mut Canvas<Window>)
where
    T: Transport + Clone,
    P: Provider<T, N>,
    N: Network,
{
    // Clear canvas as black
    canvas.set_draw_color(Color::RGB(0, 0, 0));
    canvas.clear();

    let builder = emu.getDisplay();
    let screen_buf = builder.call().await.unwrap()._0;

    // Now set draw color to white, iterate through each point and see if it should be drawn
    canvas.set_draw_color(Color::RGB(255, 255, 255));
    for (i, pixel) in screen_buf.iter().enumerate() {
        let pixel_bytes:[u8; 32]  = pixel.to_be_bytes();
        for (j, pixel_byte) in pixel_bytes.into_iter().enumerate() {
            let pixel_bits = pixel_byte.view_bits::<Msb0>();
            for (k, pixel_bit) in pixel_bits.into_iter().enumerate() {
                if *pixel_bit {
                    let index= k + (j * 8) + (i * 256);
                    // println!("index:{:?}", index);
                    // Convert our 1D array's index into a 2D (x,y) position
                    let x = (index % SCREEN_WIDTH) as u32;
                    let y = (index / SCREEN_WIDTH) as u32;
        
                    // Draw a rectangle at (x,y), scaled up by our SCALE value
                    let rect = Rect::new((x * SCALE) as i32, (y * SCALE) as i32, SCALE, SCALE);
                    canvas.fill_rect(rect).unwrap();
                }
            }
        }
       
    }
    canvas.present();
}

/*
    Keyboard                    Chip-8
    +---+---+---+---+           +---+---+---+---+
    | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 | C |
    +---+---+---+---+           +---+---+---+---+
    | Q | W | E | R |           | 4 | 5 | 6 | D |
    +---+---+---+---+     =>    +---+---+---+---+
    | A | S | D | F |           | 7 | 8 | 9 | E |
    +---+---+---+---+           +---+---+---+---+
    | Z | X | C | V |           | A | 0 | B | F |
    +---+---+---+---+           +---+---+---+---+
*/

fn key2btn(key: Keycode) -> Option<usize> {
    match key {
        Keycode::Num1 => Some(0x1),
        Keycode::Num2 => Some(0x2),
        Keycode::Num3 => Some(0x3),
        Keycode::Num4 => Some(0xC),
        Keycode::Q => Some(0x4),
        Keycode::W => Some(0x5),
        Keycode::E => Some(0x6),
        Keycode::R => Some(0xD),
        Keycode::A => Some(0x7),
        Keycode::S => Some(0x8),
        Keycode::D => Some(0x9),
        Keycode::F => Some(0xE),
        Keycode::Z => Some(0xA),
        Keycode::X => Some(0x0),
        Keycode::C => Some(0xB),
        Keycode::V => Some(0xF),
        _ => None,
    }
}
