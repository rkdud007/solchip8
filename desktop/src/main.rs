//! code is credit from https://github.com/aquova/chip8-book/tree/master/code/desktop

use std::env;
use std::fs::File;
use std::io::Read;
use std::str::FromStr;
use bitvec::prelude::*;

use alloy::network::{EthereumWallet, Network};
use alloy::primitives::U256;
use alloy::providers::ext::AnvilApi;
use alloy::providers::{Provider, ProviderBuilder};
use alloy::signers::local::PrivateKeySigner;
use alloy::sol;
use alloy::transports::http::reqwest::Url;
use alloy::transports::Transport;
use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::rect::Rect;
use sdl2::render::Canvas;
use sdl2::video::Window;
use Emu::EmuInstance;

const SCREEN_WIDTH: usize = 64;
const SCREEN_HEIGHT: usize = 32;
const SCALE: u32 = 15;
const WINDOW_WIDTH: u32 = (SCREEN_WIDTH as u32) * SCALE;
const WINDOW_HEIGHT: u32 = (SCREEN_HEIGHT as u32) * SCALE;
// const TICKS_PER_FRAME: usize = 5;

sol! {
    #[sol(rpc, bytecode="0x610a80604090815260f06080818152609060a081905260c081905260e0818152610100849052602061012081905260606101405261016081905261018081905260706101a0526101c085905260106101e08190526102008690526102208590526102408690526102608690526102808190526102a08690526102c08190526102e08690526103008490526103208490526103408690526103608190526103808190526103a08690526103c08590526103e08690526104008190526104208690526104408690526104608590526104808690526104a08490526104c08690526104e086905261050081905261052091909152610540869052610560959095526105808490526105a08290526105c08490526105e0829052610600849052610620849052610640829052610660849052610680949094526106a08390526106c08390526106e08190526107008390526107208190526107408190526107608490526107808190526107a08490526107c08190526107e08490526108008390526108208290526108408290526108608290526108808390526108a08490526108c08190526108e081905261090052610920929092526109408190526109608290526109808190526109a08290526109c08190526109e0819052610a00829052610a2052610a40819052610a608190526101f9906000906050610292565b5034801561020657600080fd5b506003805461ffff191661020017905560005b605081101561028c57600081605081106102355761023561033a565b602081049091015460ff601f9092166101000a900416600482611000811061025f5761025f61033a565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610219565b50610350565b6003830191839082156103155791602002820160005b838211156102e657835183826101000a81548160ff021916908360ff16021790555092602001926001016020816000010492830192600103026102a8565b80156103135782816101000a81549060ff02191690556001016020816000010492830192600103026102e6565b505b50610321929150610325565b5090565b5b808211156103215760008155600101610326565b634e487b7160e01b600052603260045260246000fd5b612ad08061035f6000396000f3fe608060405234801561001057600080fd5b506004361061018e5760003560e01c8063997a40c0116100de578063ae344f8e11610097578063d19dc8b511610071578063d19dc8b514610377578063d2bf2e1c14610383578063d826f88f146103a7578063e781d8c5146103af57600080fd5b8063ae344f8e1461034c578063c04062261461035c578063cbc950191461036457600080fd5b8063997a40c0146102e85780639cba24bb146102fb578063a560ea3b14610313578063a72b660414610326578063a8b3ac7814610339578063a95c372d1461034457600080fd5b806368ad83f11161014b5780638153da03116101255780638153da0314610285578063825284fd146102985780638c41bd00146102ab57806392ddeea0146102d557600080fd5b806368ad83f11461023c5780637ef914241461025d57806380bc398e1461027257600080fd5b8063074b6fac146101935780632150c5181461019d5780632f57e5f7146101bb5780633eaf5d9f146101e95780636398efc8146101f157806366050ab914610216575b600080fd5b61019b6103bb565b005b6101a5610440565b6040516101b2919061260d565b60405180910390f35b61019b6101c9366004612658565b608d805461ffff909216620100000263ffff000019909216919091179055565b61019b61049b565b6102046101ff36600461267a565b6104b3565b60405160ff90911681526020016101b2565b61019b610224366004612658565b608d805461ffff191661ffff92909216919091179055565b608d5462010000900461ffff165b60405161ffff90911681526020016101b2565b610265610535565b6040516101b29190612693565b61019b6102803660046126bc565b610571565b61019b610293366004612718565b610611565b61019b6102a63660046127e8565b6106f3565b61019b6102b9366004612814565b6090805460ff9092166101000261ff0019909216919091179055565b61019b6102e336600461282f565b610777565b61019b6102f6366004612852565b610800565b61030361086a565b60405190151581526020016101b2565b61020461032136600461267a565b6108ca565b61024a61033436600461267a565b61092f565b60905460ff16610204565b61024a6109b1565b609054610100900460ff16610204565b61019b610ae3565b61019b6103723660046126bc565b610bb6565b608d5461ffff1661024a565b61019b610391366004612814565b6090805460ff191660ff92909216919091179055565b61019b610c31565b60035461ffff1661024a565b60905460ff16156103f85760908054600191906000906103df90849060ff16612892565b92506101000a81548160ff021916908360ff1602179055505b609054610100900460ff161561043e5760908054600191908290610425908290610100900460ff16612892565b92506101000a81548160ff021916908360ff1602179055505b565b6104486125cf565b6040805161020081019182905290608f90601090826000855b825461010083900a900460ff1615158152602060019283018181049485019490930390920291018084116104615790505050505050905090565b60006104a56109b1565b90506104b081610deb565b50565b600061100082106105055760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b60448201526064015b60405180910390fd5b6004826110008110610519576105196128b1565b602081049091015460ff601f9092166101000a90041692915050565b61053d6125ee565b604080516101008101918290529060849060089082845b815481526020019060010190808311610554575050505050905090565b61080082106105b85760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b60448201526064016104fc565b80156105e757600160ff83161b6084600884811c9081106105db576105db6128b1565b01805490911790555050565b600160ff83161b196084600884811c908110610605576106056128b1565b01805490911690555050565b80516102009060009061062490836128c7565b90506110008111156106785760405162461bcd60e51b815260206004820152601c60248201527f4461746120746f6f206c6172676520746f2066697420696e2052414d0000000060448201526064016104fc565b815b818110156106e9578361068d84836128da565b8151811061069d5761069d6128b1565b602002602001015160036001018261100081106106bc576106bc6128b1565b602091828204019190066101000a81548160ff021916908360ff160217905550808060010191505061067a565b5050905160915550565b611000821061073e5760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b60448201526064016104fc565b806004836110008110610753576107536128b1565b602091828204019190066101000a81548160ff021916908360ff1602179055505050565b601082106107c35760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b60448201526064016104fc565b80608e83601081106107d7576107d76128b1565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055505050565b601060ff8316106108535760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e6473000060448201526064016104fc565b80608c60ff841660108110610753576107536128b1565b60845460009015801561087d5750608554155b80156108895750608654155b80156108955750608754155b80156108a15750608854155b80156108ad5750608954155b80156108b95750608a54155b80156108c55750608b54155b905090565b60006010821061091c5760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e6473000060448201526064016104fc565b608c8260108110610519576105196128b1565b60006010821061097d5760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b60448201526064016104fc565b608e8260108110610990576109906128b1565b601091828204019190066002029054906101000a900461ffff169050919050565b600354600090611000906109ca9061ffff1660016128ed565b61ffff1610610a1b5760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e647300000060448201526064016104fc565b60035460009060049061ffff166110008110610a3957610a396128b1565b602081049190910154600354601f9092166101000a900460ff169150600090600490610a6a9061ffff1660016128ed565b61ffff166110008110610a7f57610a7f6128b1565b60208104919091015460038054601f9093166101000a90910460ff169250600884901b62ffff001683179160029190600090610ac090849061ffff166128ed565b92506101000a81548161ffff021916908361ffff16021790555080935050505090565b609154610b265760405162461bcd60e51b8152602060048201526011602482015270050726f6772616d2073697a65206973203607c1b60448201526064016104fc565b60005b6091548110156104b057610b406001611000612907565b60035461ffff918216911610610b985760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e647300000060448201526064016104fc565b6000610ba26109b1565b9050610bad81610deb565b50600101610b29565b60108210610bfa5760405162461bcd60e51b8152602060048201526011602482015270092dcecc2d8d2c840d6caf240d2dcc8caf607b1b60448201526064016104fc565b80608f8360108110610c0e57610c0e6128b1565b602091828204019190066101000a81548160ff0219169083151502179055505050565b6003805461ffff191661020017905560005b6008811015610c6b57600060848260088110610c6157610c616128b1565b0155600101610c43565b5060005b6010811015610cba576000608c8260108110610c8d57610c8d6128b1565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610c6f565b50608d805463ffffffff1916905560005b6010811015610d1b576000608e8260108110610ce957610ce96128b1565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055508080600101915050610ccb565b5060005b6010811015610d69576000608f8260108110610d3d57610d3d6128b1565b602081049091018054921515601f9092166101000a91820260ff90920219909216179055600101610d1f565b506090805461ffff1916905560005b60508110156104b05760008160508110610d9457610d946128b1565b602081049091015460ff601f9092166101000a9004166004826110008110610dbe57610dbe6128b1565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610d78565b8061ffff16600003610dfa5750565b600f600c82901c811690600883901c811690600484901c811690841683158015610e25575060ff8316155b8015610e3457508160ff16600e145b8015610e41575060ff8116155b15610e795760005b6008811015610e7157600060848260088110610e6757610e676128b1565b0155600101610e49565b505050505050565b60ff8416158015610e8b575060ff8316155b8015610e9a57508160ff16600e145b8015610ea957508060ff16600e145b15610ed357610eb6612434565b6003805461ffff191661ffff929092169190911790555050505050565b8360ff16600103610efa5750506003805461ffff1916610fff909416939093179092555050565b8360ff16600203610f1b57600354610fff861690610eb69061ffff166124fa565b8360ff16600303610f9a5760ff808616908190608c90861660108110610f4357610f436128b1565b602081049091015460ff601f9092166101000a90041603610e71576003805460029190600090610f7890849061ffff166128ed565b92506101000a81548161ffff021916908361ffff160217905550505050505050565b8360ff16600403610ff75760ff808616908190608c90861660108110610fc257610fc26128b1565b602081049091015460ff601f9092166101000a90041614610e71576003805460029190600090610f7890849061ffff166128ed565b8360ff16600514801561100b575060ff8116155b156110aa57608c60ff831660108110611026576110266128b1565b602081049091015460ff601f9092166101000a9004811690608c90851660108110611053576110536128b1565b602081049091015460ff601f9092166101000a900416036110a357600380546002919060009061108890849061ffff166128ed565b92506101000a81548161ffff021916908361ffff1602179055505b5050505050565b8360ff166006036110fa5760ff808616908190608c908616601081106110d2576110d26128b1565b602091828204019190066101000a81548160ff021916908360ff160217905550505050505050565b8360ff166007036111655760ff808616908190608c90861660108110611122576111226128b1565b602091828204019190068282829054906101000a900460ff166111459190612921565b92506101000a81548160ff021916908360ff160217905550505050505050565b8360ff166008148015611179575060ff8116155b156111e857608c60ff831660108110611194576111946128b1565b602081049091015460ff601f9092166101000a9004811690608c908516601081106111c1576111c16128b1565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050565b8360ff1660081480156111fe57508060ff166001145b1561127f57608c60ff831660108110611219576112196128b1565b602081049091015460ff601f9092166101000a9004811690608c90851660108110611246576112466128b1565b602091828204019190068282829054906101000a900460ff161792506101000a81548160ff021916908360ff1602179055505050505050565b8360ff16600814801561129557508060ff166002145b1561130f57608c60ff8316601081106112b0576112b06128b1565b602081049091015460ff601f9092166101000a9004811690608c908516601081106112dd576112dd6128b1565b602081049091018054601f9092166101000a80830490931660ff90811684029302199091169190911790555050505050565b8360ff16600814801561132557508060ff166003145b1561139f57608c60ff831660108110611340576113406128b1565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061136d5761136d6128b1565b60208104909101805460ff601f9093166101000a80820484169094188316840292909302199092161790555050505050565b8360ff1660081480156113b557508060ff166004145b1561148f5782826000608c60ff8316601081106113d4576113d46128b1565b602081049091015460ff601f9092166101000a9004811690608c90851660108110611401576114016128b1565b6020810491909101546114209291601f166101000a900460ff166128ed565b905060ff8161ffff1611611435576000611438565b60015b608c805460ff60781b1916600160781b60ff938416021781558291851660108110611465576114656128b1565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050505050565b8360ff1660081480156114a557508060ff166005145b156115a3578282608c60ff8216601081106114c2576114c26128b1565b602081049091015460ff601f9092166101000a9004811690608c908416601081106114ef576114ef6128b1565b602081049091015460ff601f9092166101000a9004161015611512576000611515565b60015b608c805460ff60781b1916600160781b60ff9384160217815590821660108110611541576115416128b1565b602081049091015460ff601f9092166101000a9004811690608c9084166010811061156e5761156e6128b1565b60208104909101805460ff601f9093166101000a80820484169490940383168402929093021990921617905550505050505050565b8360ff1660081480156115b957508060ff166006145b1561164c5782608c60ff8216601081106115d5576115d56128b1565b602081049190910154608c805460ff60781b19166001601f9094166101000a9092048316600160781b0291909117815560ff831660108110611619576116196128b1565b60208104909101805460ff601f9093166101000a808204841690941c831684029290930219909216179055505050505050565b8360ff16600814801561166257508060ff166007145b15611784578282608c60ff83166010811061167f5761167f6128b1565b602081049091015460ff601f9092166101000a9004811690608c908316601081106116ac576116ac6128b1565b602081049091015460ff601f9092166101000a90041610156116cf5760006116d2565b60015b608c805460ff60781b1916600160781b60ff93841602178155908316601081106116fe576116fe6128b1565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061172b5761172b6128b1565b602091828204019190069054906101000a900460ff160360036089018360ff166010811061175b5761175b6128b1565b602091828204019190066101000a81548160ff021916908360ff16021790555050505050505050565b8360ff16600814801561179a57508060ff16600e145b1561183857826007608c60ff8316601081106117b8576117b86128b1565b602081049190910154608c805460ff60781b1916601f9093166101000a90910460ff90811690931c6001908116600160781b029290921781559091831660108110611805576118056128b1565b60208104909101805460ff601f9093166101000a808204841690941b831684029290930219909216179055505050505050565b8360ff16600914801561184c575060ff8116155b156118ef578282608c60ff821660108110611869576118696128b1565b602081049091015460ff601f9092166101000a9004811690608c90841660108110611896576118966128b1565b602081049091015460ff601f9092166101000a900416146118e65760038054600291906000906118cb90849061ffff166128ed565b92506101000a81548161ffff021916908361ffff1602179055505b50505050505050565b8360ff16600a03611916575050608d805461ffff1916610fff909416939093179092555050565b8360ff16600b0361195657608c54610fff86169061193890829060ff166128ed565b6003805461ffff191661ffff92909216919091179055505050505050565b8360ff16600c036119ed578260ff86166000610100426119776001436128da565b6003546040516119af9392409161ffff1690602001928352602083019190915260f01b6001600160f01b031916604082015260420190565b6040516020818303038152906040528051906020012060001c6119d29190612950565b9050818116608c60ff851660108110611465576114656128b1565b8360ff16600d03611c705760006040608c60ff861660108110611a1257611a126128b1565b602091828204019190069054906101000a900460ff16611a329190612964565b905060006020608c60ff861660108110611a4e57611a4e6128b1565b602091828204019190069054906101000a900460ff16611a6e9190612964565b608c805460ff60781b1916905590508260005b8160ff168160ff161015611c6557608d54600090600490611aaa9060ff85169061ffff166128ed565b61ffff166110008110611abf57611abf6128b1565b602081049091015460ff601f9092166101000a900416905060005b60088160ff161015611c5b576000611af3826007612892565b60ff168360ff16901c6001169050600060408389611b119190612921565b60ff16611b1e9190612986565b61ffff16905060006020611b32878a612921565b60ff16611b3f9190612986565b61ffff169050600082611b536040846129aa565b611b5d91906129d0565b90506000611b6d610100836129ec565b63ffffffff1690506000611b8361010084612a14565b63ffffffff1690506000611b988260ff6128da565b60848460088110611bab57611bab6128b1565b01546001911c8116158015925060ff8916909114821415908290611bcd575080155b15611be657608c805460ff60781b1916600160781b1790555b8015611c1b57611bf78360ff6128da565b6001901b60848560088110611c0e57611c0e6128b1565b0180549091179055611c47565b611c268360ff6128da565b6001901b1960848560088110611c3e57611c3e6128b1565b01805490911690555b505060019096019550611ada945050505050565b5050600101611a81565b505050505050505050565b8360ff16600e148015611c8657508160ff166009145b8015611c9557508060ff16600e145b15611d5457826000608c60ff831660108110611cb357611cb36128b1565b602081049091015460ff601f9092166101000a900416905060108110611d095760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b60448201526064016104fc565b608f60ff821660108110611d1f57611d1f6128b1565b602081049091015460ff601f9092166101000a900416156118e65760038054600291906000906118cb90849061ffff166128ed565b8360ff16600e148015611d6a57508160ff16600a145b8015611d7957508060ff166001145b15611e3757826000608c60ff831660108110611d9757611d976128b1565b602081049091015460ff601f9092166101000a900416905060108110611ded5760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b60448201526064016104fc565b608f60ff821660108110611e0357611e036128b1565b602081049091015460ff601f9092166101000a9004166118e65760038054600291906000906118cb90849061ffff166128ed565b8360ff16600f148015611e4b575060ff8216155b8015611e5a57508060ff166007145b15611e7f57609054839060ff90811690608c908316601081106110d2576110d26128b1565b8360ff16600f148015611e93575060ff8216155b8015611ea257508060ff16600a145b15611f5157826000805b601060ff82161015611f3157608f60ff821660108110611ece57611ece6128b1565b602081049091015460ff601f9092166101000a90041615611f295780608c60ff851660108110611f0057611f006128b1565b602091828204019190066101000a81548160ff021916908360ff16021790555060019150611f31565b600101611eac565b50806118e65760038054600291906000906118cb90849061ffff16612907565b8360ff16600f148015611f6757508160ff166001145b8015611f7657508060ff166005145b15611fbf5782608c60ff821660108110611f9257611f926128b1565b60208104909101546090805460ff191660ff601f9094166101000a90920492909216179055505050505050565b8360ff16600f148015611fd557508160ff166001145b8015611fe457508060ff166008145b156120345782608c60ff821660108110612000576120006128b1565b6020810491909101546090805461ff001916601f90931661010090810a90920460ff16909102919091179055505050505050565b8360ff16600f14801561204a57508160ff166001145b801561205957508060ff16600e145b156120a45782608c60ff821660108110612075576120756128b1565b602081049190910154608d8054601f9093166101000a90910460ff1691600090610f7890849061ffff166128ed565b8360ff16600f1480156120ba57508160ff166002145b80156120c957508060ff166009145b1561212957826000608c60ff8316601081106120e7576120e76128b1565b602081049091015460ff601f9092166101000a900416905061210a816005612a3c565b608d805461ffff191661ffff9290921691909117905550505050505050565b8360ff16600f14801561213f57508160ff166003145b801561214e57508060ff166003145b1561226357826000608c60ff83166010811061216c5761216c6128b1565b602081049091015460ff601f9092166101000a900416905061218f606482612a59565b608d5460049061ffff1661100081106121aa576121aa6128b1565b602091828204019190066101000a81548160ff021916908360ff160217905550600a80826121d89190612a59565b6121e29190612964565b608d546004906121f79061ffff1660016128ed565b61ffff16611000811061220c5761220c6128b1565b602091828204019190066101000a81548160ff021916908360ff160217905550600a816122399190612964565b608d5460049061224e9061ffff1660026128ed565b61ffff16611000811061175b5761175b6128b1565b8360ff16600f14801561227957508160ff166005145b801561228857508060ff166005145b1561232b578260005b8160ff168160ff16116118e657608c60ff8216601081106122b4576122b46128b1565b6020810490910154608d5460ff601f9093166101000a9091048216916004916122e39185169061ffff166128ed565b61ffff1661100081106122f8576122f86128b1565b602091828204019190066101000a81548160ff021916908360ff160217905550808061232390612a7b565b915050612291565b8360ff16600f14801561234157508160ff166006145b801561235057508060ff166005145b156123f3578260005b8160ff168160ff16116118e657608d5460049061237e9060ff84169061ffff166128ed565b61ffff166110008110612393576123936128b1565b602081049091015460ff601f9092166101000a9004811690608c908316601081106123c0576123c06128b1565b602091828204019190066101000a81548160ff021916908360ff16021790555080806123eb90612a7b565b915050612359565b60405162461bcd60e51b815260206004820152601660248201527513dc18dbd919481b9bdd081a5b5c1b195b595b9d195960521b60448201526064016104fc565b608d5460009062010000900461ffff166124825760405162461bcd60e51b815260206004820152600f60248201526e537461636b20756e646572666c6f7760881b60448201526064016104fc565b608d8054600191906002906124a290849062010000900461ffff16612907565b82546101009290920a61ffff818102199093169183160217909155608d54608e925062010000900416601081106124db576124db6128b1565b601091828204019190066002029054906101000a900461ffff16905090565b608d5460106201000090910461ffff16106125485760405162461bcd60e51b815260206004820152600e60248201526d537461636b206f766572666c6f7760901b60448201526064016104fc565b608d548190608e9062010000900461ffff166010811061256a5761256a6128b1565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555060016003608a0160028282829054906101000a900461ffff166125b291906128ed565b92506101000a81548161ffff021916908361ffff16021790555050565b6040518061020001604052806010906020820280368337509192915050565b6040518061010001604052806008906020820280368337509192915050565b6102008101818360005b60108110156126385781511515835260209283019290910190600101612617565b50505092915050565b803561ffff8116811461265357600080fd5b919050565b60006020828403121561266a57600080fd5b61267382612641565b9392505050565b60006020828403121561268c57600080fd5b5035919050565b6101008101818360005b600881101561263857815183526020928301929091019060010161269d565b600080604083850312156126cf57600080fd5b82359150602083013580151581146126e657600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b803560ff8116811461265357600080fd5b60006020828403121561272a57600080fd5b813567ffffffffffffffff81111561274157600080fd5b8201601f8101841361275257600080fd5b803567ffffffffffffffff81111561276c5761276c6126f1565b8060051b604051601f19603f830116810181811067ffffffffffffffff82111715612799576127996126f1565b6040529182526020818401810192908101878411156127b757600080fd5b6020850194505b838510156127dd576127cf85612707565b8152602094850194016127be565b509695505050505050565b600080604083850312156127fb57600080fd5b8235915061280b60208401612707565b90509250929050565b60006020828403121561282657600080fd5b61267382612707565b6000806040838503121561284257600080fd5b8235915061280b60208401612641565b6000806040838503121561286557600080fd5b61286e83612707565b915061280b60208401612707565b634e487b7160e01b600052601160045260246000fd5b60ff82811682821603908111156128ab576128ab61287c565b92915050565b634e487b7160e01b600052603260045260246000fd5b808201808211156128ab576128ab61287c565b818103818111156128ab576128ab61287c565b61ffff81811683821601908111156128ab576128ab61287c565b61ffff82811682821603908111156128ab576128ab61287c565b60ff81811683821601908111156128ab576128ab61287c565b634e487b7160e01b600052601260045260246000fd5b60008261295f5761295f61293a565b500690565b600060ff8316806129775761297761293a565b8060ff84160691505092915050565b600061ffff83168061299a5761299a61293a565b8061ffff84160691505092915050565b63ffffffff81811683821602908116908181146129c9576129c961287c565b5092915050565b63ffffffff81811683821601908111156128ab576128ab61287c565b600063ffffffff831680612a0257612a0261293a565b8063ffffffff84160491505092915050565b600063ffffffff831680612a2a57612a2a61293a565b8063ffffffff84160691505092915050565b61ffff81811683821602908116908181146129c9576129c961287c565b600060ff831680612a6c57612a6c61293a565b8060ff84160491505092915050565b600060ff821660ff8103612a9157612a9161287c565b6001019291505056fea264697066735822122034e21477a46241e17af5dc45f2d42b68b59c4f7dc5bbe9f5c33c643968f0a05464736f6c634300081c0033")]
    contract Emu {
        // -------------------------------------------------------------------------
        // Constants
        // -------------------------------------------------------------------------
    
        /// @notice screen width 64 pixels
        uint16 constant SCREEN_WIDTH = 64;
        /// @notice screen height 32 pixels
        uint16 constant SCREEN_HEIGHT = 32;
    
        /// @notice size of RAM
        uint16 constant RAM_SIZE = 4096;
        /// @notice number of registers
        uint8 constant NUM_REGS = 16;
        /// @notice number of stack entries
        uint8 constant STACK_SIZE = 16;
        /// @notice number of keys
        uint8 constant NUM_KEYS = 16;
    
        // -------------------------------------------------------------------------
        // Display
        // -------------------------------------------------------------------------


        /// @notice fontset size
        uint8 constant FONTSET_SIZE = 80;

        /// @notice fontset
        /// @dev Most modern emulators will use that space to store the sprite data for font characters of all the
        /// hexadecimal digits, that is characters of 0-9 and A-F. We could store this data at any fixed position in RAM, but this
        /// space is already defined as empty anyway. Each character is made up of eight rows of five pixels, with each row using
        /// a byte of data, meaning that each letter altogether takes up five bytes of data. The following diagram illustrates how
        /// a character is stored as bytes
        uint8[80] FONTSET = [
            0xF0,
            0x90,
            0x90,
            0x90,
            0xF0, // 0
            0x20,
            0x60,
            0x20,
            0x20,
            0x70, // 1
            0xF0,
            0x10,
            0xF0,
            0x80,
            0xF0, // 2
            0xF0,
            0x10,
            0xF0,
            0x10,
            0xF0, // 3
            0x90,
            0x90,
            0xF0,
            0x10,
            0x10, // 4
            0xF0,
            0x80,
            0xF0,
            0x10,
            0xF0, // 5
            0xF0,
            0x80,
            0xF0,
            0x90,
            0xF0, // 6
            0xF0,
            0x10,
            0x20,
            0x40,
            0x40, // 7
            0xF0,
            0x90,
            0xF0,
            0x90,
            0xF0, // 8
            0xF0,
            0x90,
            0xF0,
            0x10,
            0xF0, // 9
            0xF0,
            0x90,
            0xF0,
            0x90,
            0x90, // A
            0xE0,
            0x90,
            0xE0,
            0x90,
            0xE0, // B
            0xF0,
            0x80,
            0x80,
            0x80,
            0xF0, // C
            0xE0,
            0x90,
            0x90,
            0x90,
            0xE0, // D
            0xF0,
            0x80,
            0xF0,
            0x80,
            0xF0, // E
            0xF0,
            0x80,
            0xF0,
            0x80,
            0x80 // F
        ];

    
        struct Emulator {
            /// @notice 16-bit program counter
            uint16 pc;
            /// @notice 4KB RAM
            uint8[4096] ram;
            /// @notice A 64x32 monochrome display = 2048 bit = 256 * 8 bits
            uint256[8] screen;
            /// @notice Sixteen 8-bit general purpose registers, referred to as V0 thru VF
            uint8[16] v_reg;
            /// @notice Single 16-bit register used as a pointer for memory access, called the I Register
            uint16 i_reg;
            /// @notice Stack pointer
            uint16 sp;
            /// @notice 16-bit stack used for calling and returning from subroutines
            uint16[16] stack;
            /// @notice 16-key keyboard input
            bool[16] keys;
            /// @notice Delay timer
            uint8 dt;
            /// @notice Sound timer
            uint8 st;
            /// @notice Program size
            uint256 program_size;
        }
    
        Emulator emu;
    
        // -------------------------------------------------------------------------
        // Initialization
        // -------------------------------------------------------------------------
    
        /// @notice start address for program (usually 0x200)
        uint16 constant START_ADDR = 0x200;
    
        constructor() {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        /// @notice Reset the emulator
        function reset() public {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < 8; i++) {
                emu.screen[i] = 0;
            }
            for (uint256 i = 0; i < NUM_REGS; i++) {
                emu.v_reg[i] = 0;
            }
            emu.i_reg = 0;
            emu.sp = 0;
            for (uint256 i = 0; i < STACK_SIZE; i++) {
                emu.stack[i] = 0;
            }
            for (uint256 i = 0; i < NUM_KEYS; i++) {
                emu.keys[i] = false;
            }
            emu.dt = 0;
            emu.st = 0;
             // Copy FONTSET
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        // -------------------------------------------------------------------------
        // Emulation functions
        // -------------------------------------------------------------------------
    
        /// @notice Push a value onto the stack
        function push(uint16 val) internal {
            require(emu.sp < STACK_SIZE, "Stack overflow");
            emu.stack[emu.sp] = val;
            emu.sp += 1;
        }
    
        /// @notice Pop a value from the stack
        function pop() internal returns (uint16) {
            require(emu.sp > 0, "Stack underflow");
            emu.sp -= 1;
            return emu.stack[emu.sp];
        }
    
        /// @notice CPU processing loop
        /// @dev This function is called once per tick of the CPU.
        /// Fetch the next instruction, decode and execute it.
        function tick() public {
            // Fetch
            uint16 op = fetch();
            // Decode & execute
            execute(op);
        }
    
        function tickTimers() public {
            if (emu.dt > 0) {
                emu.dt -= 1;
            }
    
            if (emu.st > 0) {
                if (emu.st == 1) {
                    // BEEP
                }
                emu.st -= 1;
            }
        }
    
        /// @notice Fetch the next instruction
        function fetch() public returns (uint16) {
            require(emu.pc + 1 < RAM_SIZE, "Program counter out of bounds");
            uint16 higher_byte = uint16(emu.ram[emu.pc]);
            uint16 lower_byte = uint16(emu.ram[emu.pc + 1]);
            uint16 op = (higher_byte << 8) | lower_byte;
            emu.pc += 2;
            return op;
        }
    
        function run() public {
            require(emu.program_size > 0, "Program size is 0");
            for (uint256 i = 0; i < emu.program_size; i++) {
                require(emu.pc < RAM_SIZE - 1, "Program counter out of bounds");
                // Fetch the opcode
                uint16 op = fetch();
                // Execute the opcode
                execute(op);
            }
        }
    
        function execute(uint16 op) internal {
            // 0000 - Nop - NOP
            if (op == 0x0000) return;
    
            uint8 digit1 = uint8((op & 0xF000) >> 12);
            uint8 digit2 = uint8((op & 0x0F00) >> 8);
            uint8 digit3 = uint8((op & 0x00F0) >> 4);
            uint8 digit4 = uint8(op & 0x000F);
    
            //  00E0 - CLS
            if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0) {
                for (uint256 i = 0; i < 8; i++) {
                    emu.screen[i] = 0;
                }
                return;
            }
            // 00EE - RET
            else if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0xE) {
                emu.pc = pop();
                return;
            }
            //  1NNN - JMP NNN
            else if (digit1 == 0x1) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = nnn;
                return;
            }
            //  2NNN - CALL NNN
            else if (digit1 == 0x2) {
                uint16 nnn = op & 0x0FFF;
                push(emu.pc);
                emu.pc = nnn;
                return;
            }
            //  3NNN - SKIP VX == NN
            else if (digit1 == 0x3) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] == nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  4NNN - SKIP VX != NN
            else if (digit1 == 0x4) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] != nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  5NNN - SKIP VX == VY
            else if (digit1 == 0x5 && digit4 == 0x0) {
                if (emu.v_reg[digit2] == emu.v_reg[digit3]) {
                    emu.pc += 2;
                }
                return;
            }
            //  6NNN - VX = NN
            else if (digit1 == 0x6) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] = nn;
                return;
            }
            //  7NNN - VX += NN
            else if (digit1 == 0x7) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] += nn;
                return;
            }
            // 8XY0 - VX = VY
            else if (digit1 == 0x8 && digit4 == 0x0) {
                emu.v_reg[digit2] = emu.v_reg[digit3];
                return;
            }
            // 8XY1 - VX |= VY
            else if (digit1 == 0x8 && digit4 == 0x1) {
                emu.v_reg[digit2] |= emu.v_reg[digit3];
                return;
            }
            // 8XY2 - VX &= VY
            else if (digit1 == 0x8 && digit4 == 0x2) {
                emu.v_reg[digit2] &= emu.v_reg[digit3];
                return;
            }
            // 8XY3 - VX ^= VY
            else if (digit1 == 0x8 && digit4 == 0x3) {
                emu.v_reg[digit2] ^= emu.v_reg[digit3];
                return;
            }
            // 8XY4 - VX += VY (with carry)
            else if (digit1 == 0x8 && digit4 == 0x4) {
                uint8 x = digit2;
                uint8 y = digit3;
                uint16 sum = uint16(emu.v_reg[x]) + uint16(emu.v_reg[y]);
                emu.v_reg[0xF] = sum > 0xFF ? 1 : 0;
                emu.v_reg[x] = uint8(sum);
                return;
            }
            // 8XY5 - VX -= VY (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x5) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[x] >= emu.v_reg[y] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] -= emu.v_reg[y];
                }
                return;
            }
            // 8XY6 - VX >>= 1
            else if (digit1 == 0x8 && digit4 == 0x6) {
                uint8 x = digit2;
                emu.v_reg[0xF] = emu.v_reg[x] & 0x1;
                emu.v_reg[x] >>= 1;
                return;
            }
            // 8XY7 - VX = VY - VX (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x7) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[y] >= emu.v_reg[x] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] = emu.v_reg[y] - emu.v_reg[x];
                }
                return;
            }
            // 8XYE - VX <<= 1
            else if (digit1 == 0x8 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.v_reg[0xF] = (emu.v_reg[x] >> 7) & 0x1;
                emu.v_reg[x] <<= 1;
                return;
            }
            // 9XY0 - SKIP VX != VY
            else if (digit1 == 0x9 && digit4 == 0x0) {
                uint8 x = digit2;
                uint8 y = digit3;
                if (emu.v_reg[x] != emu.v_reg[y]) {
                    emu.pc += 2;
                }
                return;
            }
            // ANNN - I = NNN
            else if (digit1 == 0xA) {
                uint16 nnn = op & 0x0FFF;
                emu.i_reg = nnn;
                return;
            }
            // BNNN - PC = V0 + NNN
            else if (digit1 == 0xB) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = uint16(emu.v_reg[0]) + nnn;
                return;
            }
            // CXNN - VX = rand() & NN
            else if (digit1 == 0xC) {
                uint8 x = digit2;
                uint8 nn = uint8(op & 0x00FF);
                // Pseudo-random number generation (not secure)
                uint8 rand =
                    uint8(uint256(keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 1), emu.pc))) % 256);
                emu.v_reg[x] = rand & nn;
                return;
            }
            // DXYN - DRAW
            else if (digit1 == 0xD) {
                uint8 x = emu.v_reg[digit2] % uint8(SCREEN_WIDTH);
                uint8 y = emu.v_reg[digit3] % uint8(SCREEN_HEIGHT);
                uint8 height = digit4;
                emu.v_reg[0xF] = 0; // Reset VF
    
                for (uint8 row = 0; row < height; row++) {
                    uint8 sprite_byte = emu.ram[emu.i_reg + row];
                    for (uint8 col = 0; col < 8; col++) {
                        // Get the sprite pixel (bit) at the current column
                        uint8 sprite_pixel = (sprite_byte >> (7 - col)) & 0x1;
    
                        // Calculate the screen coordinates, wrapping around if necessary
                        uint32 screen_x = uint32((x + col) % SCREEN_WIDTH);
                        uint32 screen_y = uint32((y + row) % SCREEN_HEIGHT);
    
                        // Calculate the index in the display buffer
                        uint32 pixel_index = screen_y * SCREEN_WIDTH + screen_x; // Range: 0 to 2047
    
                        // Calculate the display array index and bit position
                        uint256 display_index = pixel_index / 256; // Index in emu.screen[]
                        uint256 bit_position = pixel_index % 256; // Bit position within emu.screen[display_index]
    
                        // Get the current pixel value from the display
                        bool pixel_before = ((emu.screen[display_index] >> (255 - bit_position)) & 0x1) != 0;
    
                        // Calculate the new pixel value using XOR (as per CHIP-8 drawing behavior)
                        bool new_pixel = pixel_before != (sprite_pixel == 1);
    
                        // Update the collision flag VF if a pixel is erased
                        if (pixel_before && !new_pixel) {
                            emu.v_reg[0xF] = 1;
                        }
    
                        // Update the display with the new pixel value
                        if (new_pixel) {
                            // Set the bit to 1
                            emu.screen[display_index] |= (1 << (255 - bit_position));
                        } else {
                            // Set the bit to 0
                            emu.screen[display_index] &= ~(1 << (255 - bit_position));
                        }
                    }
                }
                return;
            }
            // EX9E - SKIP if key[VX] pressed
            else if (digit1 == 0xE && digit3 == 0x9 && digit4 == 0xE) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if (emu.keys[key]) {
                    emu.pc += 2;
                }
                return;
            }
            // EXA1 - SKIP if key[VX] not pressed
            else if (digit1 == 0xE && digit3 == 0xA && digit4 == 0x1) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if (!emu.keys[key]) {
                    emu.pc += 2;
                }
                return;
            }
            // FX07 - VX = DT
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0x7) {
                uint8 x = digit2;
                emu.v_reg[x] = emu.dt;
                return;
            }
            // FX0A - Wait for key press
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0xA) {
                uint8 x = digit2;
                bool key_pressed = false;
                for (uint8 i = 0; i < NUM_KEYS; i++) {
                    if (emu.keys[i]) {
                        emu.v_reg[x] = i;
                        key_pressed = true;
                        break;
                    }
                }
                if (!key_pressed) {
                    // Repeat this opcode
                    emu.pc -= 2;
                }
                return;
            }
            // FX15 - DT = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x5) {
                uint8 x = digit2;
                emu.dt = emu.v_reg[x];
                return;
            }
            // FX18 - ST = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x8) {
                uint8 x = digit2;
                emu.st = emu.v_reg[x];
                return;
            }
            // FX1E - I += VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.i_reg += uint16(emu.v_reg[x]);
                return;
            }
            // FX29 - I = location of sprite for digit VX
            else if (digit1 == 0xF && digit3 == 0x2 && digit4 == 0x9) {
                uint8 x = digit2;
                uint8 digit = emu.v_reg[x];
                emu.i_reg = uint16(digit) * 5; // Each sprite is 5 bytes
                return;
            }
            // FX33 - Store BCD representation of VX in memory locations I, I+1, and I+2
            else if (digit1 == 0xF && digit3 == 0x3 && digit4 == 0x3) {
                uint8 x = digit2;
                uint8 value = emu.v_reg[x];
                emu.ram[emu.i_reg] = value / 100;
                emu.ram[emu.i_reg + 1] = (value / 10) % 10;
                emu.ram[emu.i_reg + 2] = value % 10;
                return;
            }
            // FX55 - Store V0 to VX in memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x5 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.ram[emu.i_reg + i] = emu.v_reg[i];
                }
                return;
            }
            // FX65 - Read V0 to VX from memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x6 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.v_reg[i] = emu.ram[emu.i_reg + i];
                }
                return;
            } else {
                revert("Opcode not implemented");
            }
        }
    
        // -------------------------------------------------------------------------
        // Frontend functions
        // -------------------------------------------------------------------------
    
        /// @notice Get display
        function getDisplay() public view returns (uint256[8] memory) {
            return emu.screen;
        }
    
        /// @notice Handle keypress event
        function keypress(uint256 idx, bool pressed) public {
            require(idx < NUM_KEYS, "Invalid key index");
            emu.keys[idx] = pressed;
        }
    
        /// @notice Load program into memory
        function load(uint8[] memory data) public {
            uint256 start = START_ADDR;
            uint256 end = START_ADDR + data.length;
            require(end <= RAM_SIZE, "Data too large to fit in RAM");
            for (uint256 i = start; i < end; i++) {
                emu.ram[i] = data[i - start];
            }
            emu.program_size = data.length;
        }
    
        // -------------------------------------------------------------------------
        // Utility functions
        // -------------------------------------------------------------------------
    
        function getPC() public view returns (uint16) {
            return emu.pc;
        }

        function getKeys() public view returns(bool[16] memory){
            return emu.keys;
        }
    
        function getRAMValueAt(uint256 index) public view returns (uint8) {
            require(index < RAM_SIZE, "RAM index out of bounds");
            return emu.ram[index];
        }
    
        function getVRegister(uint256 index) public view returns (uint8) {
            require(index < NUM_REGS, "V register index out of bounds");
            return emu.v_reg[index];
        }
    
        function setVRegister(uint8 index, uint8 value) public {
            require(index < NUM_REGS, "V register index out of bounds");
            emu.v_reg[index] = value;
        }
    
        function getIRegister() public view returns (uint16) {
            return emu.i_reg;
        }
    
        function setIRegister(uint16 value) public {
            emu.i_reg = value;
        }
    
        function setRAMValueAt(uint256 index, uint8 value) public {
            require(index < RAM_SIZE, "RAM index out of bounds");
            emu.ram[index] = value;
        }
    
        function getDelayTimer() public view returns (uint8) {
            return emu.dt;
        }
    
        function setDelayTimer(uint8 value) public {
            emu.dt = value;
        }
    
        function getSoundTimer() public view returns (uint8) {
            return emu.st;
        }
    
        function setSoundTimer(uint8 value) public {
            emu.st = value;
        }
    
        function getSP() public view returns (uint16) {
            return emu.sp;
        }
    
        function getStackValue(uint256 index) public view returns (uint16) {
            require(index < STACK_SIZE, "Stack index out of bounds");
            return emu.stack[index];
        }
    
        function setStackValue(uint256 index, uint16 value) public {
            require(index < STACK_SIZE, "Stack index out of bounds");
            emu.stack[index] = value;
        }
    
        function setSP(uint16 value) public {
            emu.sp = value;
        }
    
        function setScreenPixel(uint256 index, bool value) public {
            unchecked {
                require(index < SCREEN_WIDTH * SCREEN_HEIGHT, "Index out of bounds");
                if (value) {
                    // Set the bit to 1
                    emu.screen[index >> 8] |= 1 << (index & 255);
                } else {
                    // Set the bit to 0
                    emu.screen[index >> 8] &= ~(1 << (index & 255));
                }
            }
        }
    
        function isDisplayCleared() public view returns (bool) {
            return (
                emu.screen[0] == 0 && emu.screen[1] == 0 && emu.screen[2] == 0 && emu.screen[3] == 0 && emu.screen[4] == 0
                    && emu.screen[5] == 0 && emu.screen[6] == 0 && emu.screen[7] == 0
            );
        }
    }    
}

#[tokio::main]
async fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: cargo run path/to/game");
        return;
    }

    // Setup SDL
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let window = video_subsystem
        .window("Chip-8 Emulator", WINDOW_WIDTH, WINDOW_HEIGHT)
        .position_centered()
        .opengl()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    canvas.clear();
    canvas.present();
    let mut event_pump = sdl_context.event_pump().unwrap();
    // testing anvil account
    let signer: PrivateKeySigner = PrivateKeySigner::from_str(
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    )
    .unwrap();
    let wallet = EthereumWallet::from(signer);

    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(Url::from_str("http://localhost:8545").unwrap());

    // Get node info using the Anvil API.
    let info = provider.anvil_node_info().await.unwrap();

    println!("Node info: {:#?}", info);

    let chip8 = Emu::deploy(&provider).await.unwrap();
    // commented out, address that deployed on sepolia
    // let address = Address::from_str("0x8494dba7A8958629fE3e55D8F7F5eAF22978a467").unwrap();
    // let chip8 = Emu::new(address, &provider);

    let mut rom = File::open(&args[1]).expect("Unable to open file");
    let mut buffer = Vec::new();

    rom.read_to_end(&mut buffer).unwrap();
    println!("Loaded ROM with {:?} bytes", buffer);
    let builder = chip8.load(buffer.to_vec());
    builder.call().await.unwrap();
    // 250ms
    let tx = builder.send().await.unwrap().get_receipt().await.unwrap();
    println!("load tx: {:?}", tx);
    let r = chip8.getRAMValueAt(U256::from(512)).call().await.unwrap();
    // Check loaded successfully
    assert_eq!(r._0, buffer[0]);

    'gameloop: loop {
        let now = std::time::Instant::now();
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::Escape),
                    ..
                } => {
                    break 'gameloop;
                }
                Event::KeyDown {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), true);
                        builder.call().await.unwrap();

                        let keys = chip8.getKeys().call().await.unwrap();
                        println!("keys: {:?}", keys._0);

                        if !keys._0[k]{
                            let tx = builder.send().await.unwrap();
                            println!(" key {:?} down tx: {:?}", key, tx);
                        }
                      
                    }
                }
                Event::KeyUp {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), false);
                        builder.call().await.unwrap();

                        let keys = chip8.getKeys().call().await.unwrap();
                        println!("keys: {:?}", keys._0);

                        if keys._0[k]{
                            let tx = builder.send().await.unwrap();
                            println!(" key {:?} up tx: {:?}", key, tx);
                        }
                    }
                }
                _ => (),
            }
        }

        // TODO: I want to have tick per frame
        // for _ in 0..TICKS_PER_FRAME {}
        let builder = chip8.tick();
        builder.call().await.unwrap();
        // 250ms
        let tx = builder.send().await.unwrap().get_receipt().await.unwrap();
        println!("tx:{:?}", tx);

        let pc = chip8.getPC().call().await.unwrap();
        println!("PC: {:?}", pc._0);

        let keys = chip8.getKeys().call().await.unwrap();
        println!("keys: {:?}", keys._0);
        chip8.tickTimers().call().await.unwrap();
        draw_screen(&chip8, &mut canvas).await;

        let end = std::time::Instant::now();
        println!(" duration :{:?}", end.duration_since(now));
    }
}

async fn draw_screen<T, P, N>(emu: &EmuInstance<T, P, N>, canvas: &mut Canvas<Window>)
where
    T: Transport + Clone,
    P: Provider<T, N>,
    N: Network,
{
    // Clear canvas as black
    canvas.set_draw_color(Color::RGB(0, 0, 0));
    canvas.clear();

    let builder = emu.getDisplay();
    let screen_buf = builder.call().await.unwrap()._0;

    // Now set draw color to white, iterate through each point and see if it should be drawn
    canvas.set_draw_color(Color::RGB(255, 255, 255));
    for (i, pixel) in screen_buf.iter().enumerate() {
        let pixel_bytes:[u8; 32]  = pixel.to_be_bytes();
        for (j, pixel_byte) in pixel_bytes.into_iter().enumerate() {
            let pixel_bits = pixel_byte.view_bits::<Msb0>();
            for (k, pixel_bit) in pixel_bits.into_iter().enumerate() {
                if *pixel_bit {
                    let index= k + (j * 8) + (i * 256);
                    // println!("index:{:?}", index);
                    // Convert our 1D array's index into a 2D (x,y) position
                    let x = (index % SCREEN_WIDTH) as u32;
                    let y = (index / SCREEN_WIDTH) as u32;
        
                    // Draw a rectangle at (x,y), scaled up by our SCALE value
                    let rect = Rect::new((x * SCALE) as i32, (y * SCALE) as i32, SCALE, SCALE);
                    canvas.fill_rect(rect).unwrap();
                }
            }
        }
       
    }
    canvas.present();
}

/*
    Keyboard                    Chip-8
    +---+---+---+---+           +---+---+---+---+
    | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 | C |
    +---+---+---+---+           +---+---+---+---+
    | Q | W | E | R |           | 4 | 5 | 6 | D |
    +---+---+---+---+     =>    +---+---+---+---+
    | A | S | D | F |           | 7 | 8 | 9 | E |
    +---+---+---+---+           +---+---+---+---+
    | Z | X | C | V |           | A | 0 | B | F |
    +---+---+---+---+           +---+---+---+---+
*/

fn key2btn(key: Keycode) -> Option<usize> {
    match key {
        Keycode::Num1 => Some(0x1),
        Keycode::Num2 => Some(0x2),
        Keycode::Num3 => Some(0x3),
        Keycode::Num4 => Some(0xC),
        Keycode::Q => Some(0x4),
        Keycode::W => Some(0x5),
        Keycode::E => Some(0x6),
        Keycode::R => Some(0xD),
        Keycode::A => Some(0x7),
        Keycode::S => Some(0x8),
        Keycode::D => Some(0x9),
        Keycode::F => Some(0xE),
        Keycode::Z => Some(0xA),
        Keycode::X => Some(0x0),
        Keycode::C => Some(0xB),
        Keycode::V => Some(0xF),
        _ => None,
    }
}
