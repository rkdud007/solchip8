//! code is credit from https://github.com/aquova/chip8-book/tree/master/code/desktop

use std::env;
use std::fs::File;
use std::io::Read;
use std::str::FromStr;
use bitvec::prelude::*;

use alloy::network::{EthereumWallet, Network};
use alloy::primitives::U256;
use alloy::providers::ext::AnvilApi;
use alloy::providers::{Provider, ProviderBuilder};
use alloy::signers::local::PrivateKeySigner;
use alloy::sol;
use alloy::transports::http::reqwest::Url;
use alloy::transports::Transport;
use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::rect::Rect;
use sdl2::render::Canvas;
use sdl2::video::Window;
use Emu::EmuInstance;

const SCREEN_WIDTH: usize = 64;
const SCREEN_HEIGHT: usize = 32;
const SCALE: u32 = 15;
const WINDOW_WIDTH: u32 = (SCREEN_WIDTH as u32) * SCALE;
const WINDOW_HEIGHT: u32 = (SCREEN_HEIGHT as u32) * SCALE;
// const TICKS_PER_FRAME: usize = 5;

sol! {
    #[sol(rpc, bytecode="0x610a80604090815260f06080818152609060a081905260c081905260e0818152610100849052602061012081905260606101405261016081905261018081905260706101a0526101c085905260106101e08190526102008690526102208590526102408690526102608690526102808190526102a08690526102c08190526102e08690526103008490526103208490526103408690526103608190526103808190526103a08690526103c08590526103e08690526104008190526104208690526104408690526104608590526104808690526104a08490526104c08690526104e086905261050081905261052091909152610540869052610560959095526105808490526105a08290526105c08490526105e0829052610600849052610620849052610640829052610660849052610680949094526106a08390526106c08390526106e08190526107008390526107208190526107408190526107608490526107808190526107a08490526107c08190526107e08490526108008390526108208290526108408290526108608290526108808390526108a08490526108c08190526108e081905261090052610920929092526109408190526109608290526109808190526109a08290526109c08190526109e0819052610a00829052610a2052610a40819052610a608190526101f9906000906050610292565b5034801561020657600080fd5b506003805461ffff191661020017905560005b605081101561028c57600081605081106102355761023561033a565b602081049091015460ff601f9092166101000a900416600482611000811061025f5761025f61033a565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610219565b50610350565b6003830191839082156103155791602002820160005b838211156102e657835183826101000a81548160ff021916908360ff16021790555092602001926001016020816000010492830192600103026102a8565b80156103135782816101000a81549060ff02191690556001016020816000010492830192600103026102e6565b505b50610321929150610325565b5090565b5b808211156103215760008155600101610326565b634e487b7160e01b600052603260045260246000fd5b612ab58061035f6000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c8063997a40c0116100de578063ae344f8e11610097578063d19dc8b511610071578063d19dc8b514610354578063d2bf2e1c14610360578063d826f88f14610384578063e781d8c51461038c57600080fd5b8063ae344f8e14610329578063c040622614610339578063cbc950191461034157600080fd5b8063997a40c0146102c55780639cba24bb146102d8578063a560ea3b146102f0578063a72b660414610303578063a8b3ac7814610316578063a95c372d1461032157600080fd5b80637ef91424116101305780637ef914241461023a57806380bc398e1461024f5780638153da0314610262578063825284fd146102755780638c41bd001461028857806392ddeea0146102b257600080fd5b80632150c518146101785780632f57e5f7146101965780633eaf5d9f146101c65780636398efc8146101ce57806366050ab9146101f357806368ad83f114610219575b600080fd5b610180610398565b60405161018d91906125f2565b60405180910390f35b6101c46101a436600461263d565b608d805461ffff909216620100000263ffff000019909216919091179055565b005b6101c46103f3565b6101e16101dc36600461265f565b610413565b60405160ff909116815260200161018d565b6101c461020136600461263d565b608d805461ffff191661ffff92909216919091179055565b608d5462010000900461ffff165b60405161ffff909116815260200161018d565b610242610495565b60405161018d9190612678565b6101c461025d3660046126a1565b6104d1565b6101c46102703660046126fd565b610571565b6101c46102833660046127cd565b610653565b6101c46102963660046127f9565b6090805460ff9092166101000261ff0019909216919091179055565b6101c46102c0366004612814565b6106d7565b6101c46102d3366004612837565b610760565b6102e06107ca565b604051901515815260200161018d565b6101e16102fe36600461265f565b61082a565b61022761031136600461265f565b61088f565b60905460ff166101e1565b610227610911565b609054610100900460ff166101e1565b6101c4610a43565b6101c461034f3660046126a1565b610b16565b608d5461ffff16610227565b6101c461036e3660046127f9565b6090805460ff191660ff92909216919091179055565b6101c4610b91565b60035461ffff16610227565b6103a06125b4565b6040805161020081019182905290608f90601090826000855b825461010083900a900460ff1615158152602060019283018181049485019490930390920291018084116103b95790505050505050905090565b60006103fd610911565b905061040881610d4b565b610410612394565b50565b600061100082106104655760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b60448201526064015b60405180910390fd5b600482611000811061047957610479612861565b602081049091015460ff601f9092166101000a90041692915050565b61049d6125d3565b604080516101008101918290529060849060089082845b8154815260200190600101908083116104b4575050505050905090565b61080082106105185760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b604482015260640161045c565b801561054757600160ff83161b6084600884811c90811061053b5761053b612861565b01805490911790555050565b600160ff83161b196084600884811c90811061056557610565612861565b01805490911690555050565b805161020090600090610584908361288d565b90506110008111156105d85760405162461bcd60e51b815260206004820152601c60248201527f4461746120746f6f206c6172676520746f2066697420696e2052414d00000000604482015260640161045c565b815b8181101561064957836105ed84836128a6565b815181106105fd576105fd612861565b6020026020010151600360010182611000811061061c5761061c612861565b602091828204019190066101000a81548160ff021916908360ff16021790555080806001019150506105da565b5050905160915550565b611000821061069e5760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b604482015260640161045c565b8060048361100081106106b3576106b3612861565b602091828204019190066101000a81548160ff021916908360ff1602179055505050565b601082106107235760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b604482015260640161045c565b80608e836010811061073757610737612861565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055505050565b601060ff8316106107b35760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e64730000604482015260640161045c565b80608c60ff8416601081106106b3576106b3612861565b6084546000901580156107dd5750608554155b80156107e95750608654155b80156107f55750608754155b80156108015750608854155b801561080d5750608954155b80156108195750608a54155b80156108255750608b54155b905090565b60006010821061087c5760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e64730000604482015260640161045c565b608c826010811061047957610479612861565b6000601082106108dd5760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b604482015260640161045c565b608e82601081106108f0576108f0612861565b601091828204019190066002029054906101000a900461ffff169050919050565b6003546000906110009061092a9061ffff1660016128b9565b61ffff161061097b5760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e6473000000604482015260640161045c565b60035460009060049061ffff16611000811061099957610999612861565b602081049190910154600354601f9092166101000a900460ff1691506000906004906109ca9061ffff1660016128b9565b61ffff1661100081106109df576109df612861565b60208104919091015460038054601f9093166101000a90910460ff169250600884901b62ffff001683179160029190600090610a2090849061ffff166128b9565b92506101000a81548161ffff021916908361ffff16021790555080935050505090565b609154610a865760405162461bcd60e51b8152602060048201526011602482015270050726f6772616d2073697a65206973203607c1b604482015260640161045c565b60005b60915481101561041057610aa060016110006128d3565b60035461ffff918216911610610af85760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e6473000000604482015260640161045c565b6000610b02610911565b9050610b0d81610d4b565b50600101610a89565b60108210610b5a5760405162461bcd60e51b8152602060048201526011602482015270092dcecc2d8d2c840d6caf240d2dcc8caf607b1b604482015260640161045c565b80608f8360108110610b6e57610b6e612861565b602091828204019190066101000a81548160ff0219169083151502179055505050565b6003805461ffff191661020017905560005b6008811015610bcb57600060848260088110610bc157610bc1612861565b0155600101610ba3565b5060005b6010811015610c1a576000608c8260108110610bed57610bed612861565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610bcf565b50608d805463ffffffff1916905560005b6010811015610c7b576000608e8260108110610c4957610c49612861565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055508080600101915050610c2b565b5060005b6010811015610cc9576000608f8260108110610c9d57610c9d612861565b602081049091018054921515601f9092166101000a91820260ff90920219909216179055600101610c7f565b506090805461ffff1916905560005b60508110156104105760008160508110610cf457610cf4612861565b602081049091015460ff601f9092166101000a9004166004826110008110610d1e57610d1e612861565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610cd8565b8061ffff16600003610d5a5750565b600f600c82901c811690600883901c811690600484901c811690841683158015610d85575060ff8316155b8015610d9457508160ff16600e145b8015610da1575060ff8116155b15610dd95760005b6008811015610dd157600060848260088110610dc757610dc7612861565b0155600101610da9565b505050505050565b60ff8416158015610deb575060ff8316155b8015610dfa57508160ff16600e145b8015610e0957508060ff16600e145b15610e3357610e16612419565b6003805461ffff191661ffff929092169190911790555050505050565b8360ff16600103610e5a5750506003805461ffff1916610fff909416939093179092555050565b8360ff16600203610e7b57600354610fff861690610e169061ffff166124df565b8360ff16600303610efa5760ff808616908190608c90861660108110610ea357610ea3612861565b602081049091015460ff601f9092166101000a90041603610dd1576003805460029190600090610ed890849061ffff166128b9565b92506101000a81548161ffff021916908361ffff160217905550505050505050565b8360ff16600403610f575760ff808616908190608c90861660108110610f2257610f22612861565b602081049091015460ff601f9092166101000a90041614610dd1576003805460029190600090610ed890849061ffff166128b9565b8360ff166005148015610f6b575060ff8116155b1561100a57608c60ff831660108110610f8657610f86612861565b602081049091015460ff601f9092166101000a9004811690608c90851660108110610fb357610fb3612861565b602081049091015460ff601f9092166101000a90041603611003576003805460029190600090610fe890849061ffff166128b9565b92506101000a81548161ffff021916908361ffff1602179055505b5050505050565b8360ff1660060361105a5760ff808616908190608c9086166010811061103257611032612861565b602091828204019190066101000a81548160ff021916908360ff160217905550505050505050565b8360ff166007036110c55760ff808616908190608c9086166010811061108257611082612861565b602091828204019190068282829054906101000a900460ff166110a591906128ed565b92506101000a81548160ff021916908360ff160217905550505050505050565b8360ff1660081480156110d9575060ff8116155b1561114857608c60ff8316601081106110f4576110f4612861565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061112157611121612861565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050565b8360ff16600814801561115e57508060ff166001145b156111df57608c60ff83166010811061117957611179612861565b602081049091015460ff601f9092166101000a9004811690608c908516601081106111a6576111a6612861565b602091828204019190068282829054906101000a900460ff161792506101000a81548160ff021916908360ff1602179055505050505050565b8360ff1660081480156111f557508060ff166002145b1561126f57608c60ff83166010811061121057611210612861565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061123d5761123d612861565b602081049091018054601f9092166101000a80830490931660ff90811684029302199091169190911790555050505050565b8360ff16600814801561128557508060ff166003145b156112ff57608c60ff8316601081106112a0576112a0612861565b602081049091015460ff601f9092166101000a9004811690608c908516601081106112cd576112cd612861565b60208104909101805460ff601f9093166101000a80820484169094188316840292909302199092161790555050505050565b8360ff16600814801561131557508060ff166004145b156113ef5782826000608c60ff83166010811061133457611334612861565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061136157611361612861565b6020810491909101546113809291601f166101000a900460ff166128b9565b905060ff8161ffff1611611395576000611398565b60015b608c805460ff60781b1916600160781b60ff9384160217815582918516601081106113c5576113c5612861565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050505050565b8360ff16600814801561140557508060ff166005145b15611503578282608c60ff82166010811061142257611422612861565b602081049091015460ff601f9092166101000a9004811690608c9084166010811061144f5761144f612861565b602081049091015460ff601f9092166101000a9004161015611472576000611475565b60015b608c805460ff60781b1916600160781b60ff93841602178155908216601081106114a1576114a1612861565b602081049091015460ff601f9092166101000a9004811690608c908416601081106114ce576114ce612861565b60208104909101805460ff601f9093166101000a80820484169490940383168402929093021990921617905550505050505050565b8360ff16600814801561151957508060ff166006145b156115ac5782608c60ff82166010811061153557611535612861565b602081049190910154608c805460ff60781b19166001601f9094166101000a9092048316600160781b0291909117815560ff83166010811061157957611579612861565b60208104909101805460ff601f9093166101000a808204841690941c831684029290930219909216179055505050505050565b8360ff1660081480156115c257508060ff166007145b156116e4578282608c60ff8316601081106115df576115df612861565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061160c5761160c612861565b602081049091015460ff601f9092166101000a900416101561162f576000611632565b60015b608c805460ff60781b1916600160781b60ff938416021781559083166010811061165e5761165e612861565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061168b5761168b612861565b602091828204019190069054906101000a900460ff160360036089018360ff16601081106116bb576116bb612861565b602091828204019190066101000a81548160ff021916908360ff16021790555050505050505050565b8360ff1660081480156116fa57508060ff16600e145b1561179857826007608c60ff83166010811061171857611718612861565b602081049190910154608c805460ff60781b1916601f9093166101000a90910460ff90811690931c6001908116600160781b02929092178155909183166010811061176557611765612861565b60208104909101805460ff601f9093166101000a808204841690941b831684029290930219909216179055505050505050565b8360ff1660091480156117ac575060ff8116155b1561184f578282608c60ff8216601081106117c9576117c9612861565b602081049091015460ff601f9092166101000a9004811690608c908416601081106117f6576117f6612861565b602081049091015460ff601f9092166101000a9004161461184657600380546002919060009061182b90849061ffff166128b9565b92506101000a81548161ffff021916908361ffff1602179055505b50505050505050565b8360ff16600a03611876575050608d805461ffff1916610fff909416939093179092555050565b8360ff16600b036118b657608c54610fff86169061189890829060ff166128b9565b6003805461ffff191661ffff92909216919091179055505050505050565b8360ff16600c0361194d578260ff86166000610100426118d76001436128a6565b60035460405161190f9392409161ffff1690602001928352602083019190915260f01b6001600160f01b031916604082015260420190565b6040516020818303038152906040528051906020012060001c611932919061291c565b9050818116608c60ff8516601081106113c5576113c5612861565b8360ff16600d03611bd05760006040608c60ff86166010811061197257611972612861565b602091828204019190069054906101000a900460ff166119929190612930565b905060006020608c60ff8616601081106119ae576119ae612861565b602091828204019190069054906101000a900460ff166119ce9190612930565b608c805460ff60781b1916905590508260005b8160ff168160ff161015611bc557608d54600090600490611a0a9060ff85169061ffff166128b9565b61ffff166110008110611a1f57611a1f612861565b602081049091015460ff601f9092166101000a900416905060005b60088160ff161015611bbb576000611a53826007612952565b60ff168360ff16901c6001169050600060408389611a7191906128ed565b60ff16611a7e919061296b565b61ffff16905060006020611a92878a6128ed565b60ff16611a9f919061296b565b61ffff169050600082611ab360408461298f565b611abd91906129b5565b90506000611acd610100836129d1565b63ffffffff1690506000611ae3610100846129f9565b63ffffffff1690506000611af88260ff6128a6565b60848460088110611b0b57611b0b612861565b01546001911c8116158015925060ff8916909114821415908290611b2d575080155b15611b4657608c805460ff60781b1916600160781b1790555b8015611b7b57611b578360ff6128a6565b6001901b60848560088110611b6e57611b6e612861565b0180549091179055611ba7565b611b868360ff6128a6565b6001901b1960848560088110611b9e57611b9e612861565b01805490911690555b505060019096019550611a3a945050505050565b50506001016119e1565b505050505050505050565b8360ff16600e148015611be657508160ff166009145b8015611bf557508060ff16600e145b15611cb457826000608c60ff831660108110611c1357611c13612861565b602081049091015460ff601f9092166101000a900416905060108110611c695760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b604482015260640161045c565b608f60ff821660108110611c7f57611c7f612861565b602081049091015460ff601f9092166101000a9004161561184657600380546002919060009061182b90849061ffff166128b9565b8360ff16600e148015611cca57508160ff16600a145b8015611cd957508060ff166001145b15611d9757826000608c60ff831660108110611cf757611cf7612861565b602081049091015460ff601f9092166101000a900416905060108110611d4d5760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b604482015260640161045c565b608f60ff821660108110611d6357611d63612861565b602081049091015460ff601f9092166101000a90041661184657600380546002919060009061182b90849061ffff166128b9565b8360ff16600f148015611dab575060ff8216155b8015611dba57508060ff166007145b15611ddf57609054839060ff90811690608c9083166010811061103257611032612861565b8360ff16600f148015611df3575060ff8216155b8015611e0257508060ff16600a145b15611eb157826000805b601060ff82161015611e9157608f60ff821660108110611e2e57611e2e612861565b602081049091015460ff601f9092166101000a90041615611e895780608c60ff851660108110611e6057611e60612861565b602091828204019190066101000a81548160ff021916908360ff16021790555060019150611e91565b600101611e0c565b508061184657600380546002919060009061182b90849061ffff166128d3565b8360ff16600f148015611ec757508160ff166001145b8015611ed657508060ff166005145b15611f1f5782608c60ff821660108110611ef257611ef2612861565b60208104909101546090805460ff191660ff601f9094166101000a90920492909216179055505050505050565b8360ff16600f148015611f3557508160ff166001145b8015611f4457508060ff166008145b15611f945782608c60ff821660108110611f6057611f60612861565b6020810491909101546090805461ff001916601f90931661010090810a90920460ff16909102919091179055505050505050565b8360ff16600f148015611faa57508160ff166001145b8015611fb957508060ff16600e145b156120045782608c60ff821660108110611fd557611fd5612861565b602081049190910154608d8054601f9093166101000a90910460ff1691600090610ed890849061ffff166128b9565b8360ff16600f14801561201a57508160ff166002145b801561202957508060ff166009145b1561208957826000608c60ff83166010811061204757612047612861565b602081049091015460ff601f9092166101000a900416905061206a816005612a21565b608d805461ffff191661ffff9290921691909117905550505050505050565b8360ff16600f14801561209f57508160ff166003145b80156120ae57508060ff166003145b156121c357826000608c60ff8316601081106120cc576120cc612861565b602081049091015460ff601f9092166101000a90041690506120ef606482612a3e565b608d5460049061ffff16611000811061210a5761210a612861565b602091828204019190066101000a81548160ff021916908360ff160217905550600a80826121389190612a3e565b6121429190612930565b608d546004906121579061ffff1660016128b9565b61ffff16611000811061216c5761216c612861565b602091828204019190066101000a81548160ff021916908360ff160217905550600a816121999190612930565b608d546004906121ae9061ffff1660026128b9565b61ffff1661100081106116bb576116bb612861565b8360ff16600f1480156121d957508160ff166005145b80156121e857508060ff166005145b1561228b578260005b8160ff168160ff161161184657608c60ff82166010811061221457612214612861565b6020810490910154608d5460ff601f9093166101000a9091048216916004916122439185169061ffff166128b9565b61ffff16611000811061225857612258612861565b602091828204019190066101000a81548160ff021916908360ff160217905550808061228390612a60565b9150506121f1565b8360ff16600f1480156122a157508160ff166006145b80156122b057508060ff166005145b15612353578260005b8160ff168160ff161161184657608d546004906122de9060ff84169061ffff166128b9565b61ffff1661100081106122f3576122f3612861565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061232057612320612861565b602091828204019190066101000a81548160ff021916908360ff160217905550808061234b90612a60565b9150506122b9565b60405162461bcd60e51b815260206004820152601660248201527513dc18dbd919481b9bdd081a5b5c1b195b595b9d195960521b604482015260640161045c565b60905460ff16156123d15760908054600191906000906123b890849060ff16612952565b92506101000a81548160ff021916908360ff1602179055505b609054610100900460ff161561241757609080546001919082906123fe908290610100900460ff16612952565b92506101000a81548160ff021916908360ff1602179055505b565b608d5460009062010000900461ffff166124675760405162461bcd60e51b815260206004820152600f60248201526e537461636b20756e646572666c6f7760881b604482015260640161045c565b608d80546001919060029061248790849062010000900461ffff166128d3565b82546101009290920a61ffff818102199093169183160217909155608d54608e925062010000900416601081106124c0576124c0612861565b601091828204019190066002029054906101000a900461ffff16905090565b608d5460106201000090910461ffff161061252d5760405162461bcd60e51b815260206004820152600e60248201526d537461636b206f766572666c6f7760901b604482015260640161045c565b608d548190608e9062010000900461ffff166010811061254f5761254f612861565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555060016003608a0160028282829054906101000a900461ffff1661259791906128b9565b92506101000a81548161ffff021916908361ffff16021790555050565b6040518061020001604052806010906020820280368337509192915050565b6040518061010001604052806008906020820280368337509192915050565b6102008101818360005b601081101561261d57815115158352602092830192909101906001016125fc565b50505092915050565b803561ffff8116811461263857600080fd5b919050565b60006020828403121561264f57600080fd5b61265882612626565b9392505050565b60006020828403121561267157600080fd5b5035919050565b6101008101818360005b600881101561261d578151835260209283019290910190600101612682565b600080604083850312156126b457600080fd5b82359150602083013580151581146126cb57600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b803560ff8116811461263857600080fd5b60006020828403121561270f57600080fd5b813567ffffffffffffffff81111561272657600080fd5b8201601f8101841361273757600080fd5b803567ffffffffffffffff811115612751576127516126d6565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561277e5761277e6126d6565b60405291825260208184018101929081018784111561279c57600080fd5b6020850194505b838510156127c2576127b4856126ec565b8152602094850194016127a3565b509695505050505050565b600080604083850312156127e057600080fd5b823591506127f0602084016126ec565b90509250929050565b60006020828403121561280b57600080fd5b612658826126ec565b6000806040838503121561282757600080fd5b823591506127f060208401612626565b6000806040838503121561284a57600080fd5b612853836126ec565b91506127f0602084016126ec565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b808201808211156128a0576128a0612877565b92915050565b818103818111156128a0576128a0612877565b61ffff81811683821601908111156128a0576128a0612877565b61ffff82811682821603908111156128a0576128a0612877565b60ff81811683821601908111156128a0576128a0612877565b634e487b7160e01b600052601260045260246000fd5b60008261292b5761292b612906565b500690565b600060ff83168061294357612943612906565b8060ff84160691505092915050565b60ff82811682821603908111156128a0576128a0612877565b600061ffff83168061297f5761297f612906565b8061ffff84160691505092915050565b63ffffffff81811683821602908116908181146129ae576129ae612877565b5092915050565b63ffffffff81811683821601908111156128a0576128a0612877565b600063ffffffff8316806129e7576129e7612906565b8063ffffffff84160491505092915050565b600063ffffffff831680612a0f57612a0f612906565b8063ffffffff84160691505092915050565b61ffff81811683821602908116908181146129ae576129ae612877565b600060ff831680612a5157612a51612906565b8060ff84160491505092915050565b600060ff821660ff8103612a7657612a76612877565b6001019291505056fea264697066735822122095c615f974720634118aa982d5683aa22405f69d912f463c36ac25413153757764736f6c634300081c0033")]
    contract Emu {
        // -------------------------------------------------------------------------
        // Constants
        // -------------------------------------------------------------------------
    
        /// @notice screen width 64 pixels
        uint16 constant SCREEN_WIDTH = 64;
        /// @notice screen height 32 pixels
        uint16 constant SCREEN_HEIGHT = 32;
    
        /// @notice size of RAM
        uint16 constant RAM_SIZE = 4096;
        /// @notice number of registers
        uint8 constant NUM_REGS = 16;
        /// @notice number of stack entries
        uint8 constant STACK_SIZE = 16;
        /// @notice number of keys
        uint8 constant NUM_KEYS = 16;
    
        // -------------------------------------------------------------------------
        // Display
        // -------------------------------------------------------------------------


        /// @notice fontset size
        uint8 constant FONTSET_SIZE = 80;

        /// @notice fontset
        /// @dev Most modern emulators will use that space to store the sprite data for font characters of all the
        /// hexadecimal digits, that is characters of 0-9 and A-F. We could store this data at any fixed position in RAM, but this
        /// space is already defined as empty anyway. Each character is made up of eight rows of five pixels, with each row using
        /// a byte of data, meaning that each letter altogether takes up five bytes of data. The following diagram illustrates how
        /// a character is stored as bytes
        uint8[80] FONTSET = [
            0xF0,
            0x90,
            0x90,
            0x90,
            0xF0, // 0
            0x20,
            0x60,
            0x20,
            0x20,
            0x70, // 1
            0xF0,
            0x10,
            0xF0,
            0x80,
            0xF0, // 2
            0xF0,
            0x10,
            0xF0,
            0x10,
            0xF0, // 3
            0x90,
            0x90,
            0xF0,
            0x10,
            0x10, // 4
            0xF0,
            0x80,
            0xF0,
            0x10,
            0xF0, // 5
            0xF0,
            0x80,
            0xF0,
            0x90,
            0xF0, // 6
            0xF0,
            0x10,
            0x20,
            0x40,
            0x40, // 7
            0xF0,
            0x90,
            0xF0,
            0x90,
            0xF0, // 8
            0xF0,
            0x90,
            0xF0,
            0x10,
            0xF0, // 9
            0xF0,
            0x90,
            0xF0,
            0x90,
            0x90, // A
            0xE0,
            0x90,
            0xE0,
            0x90,
            0xE0, // B
            0xF0,
            0x80,
            0x80,
            0x80,
            0xF0, // C
            0xE0,
            0x90,
            0x90,
            0x90,
            0xE0, // D
            0xF0,
            0x80,
            0xF0,
            0x80,
            0xF0, // E
            0xF0,
            0x80,
            0xF0,
            0x80,
            0x80 // F
        ];

    
        struct Emulator {
            /// @notice 16-bit program counter
            uint16 pc;
            /// @notice 4KB RAM
            uint8[4096] ram;
            /// @notice A 64x32 monochrome display = 2048 bit = 256 * 8 bits
            uint256[8] screen;
            /// @notice Sixteen 8-bit general purpose registers, referred to as V0 thru VF
            uint8[16] v_reg;
            /// @notice Single 16-bit register used as a pointer for memory access, called the I Register
            uint16 i_reg;
            /// @notice Stack pointer
            uint16 sp;
            /// @notice 16-bit stack used for calling and returning from subroutines
            uint16[16] stack;
            /// @notice 16-key keyboard input
            bool[16] keys;
            /// @notice Delay timer
            uint8 dt;
            /// @notice Sound timer
            uint8 st;
            /// @notice Program size
            uint256 program_size;
        }
    
        Emulator emu;
    
        // -------------------------------------------------------------------------
        // Initialization
        // -------------------------------------------------------------------------
    
        /// @notice start address for program (usually 0x200)
        uint16 constant START_ADDR = 0x200;
    
        constructor() {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        /// @notice Reset the emulator
        function reset() public {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < 8; i++) {
                emu.screen[i] = 0;
            }
            for (uint256 i = 0; i < NUM_REGS; i++) {
                emu.v_reg[i] = 0;
            }
            emu.i_reg = 0;
            emu.sp = 0;
            for (uint256 i = 0; i < STACK_SIZE; i++) {
                emu.stack[i] = 0;
            }
            for (uint256 i = 0; i < NUM_KEYS; i++) {
                emu.keys[i] = false;
            }
            emu.dt = 0;
            emu.st = 0;
             // Copy FONTSET
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        // -------------------------------------------------------------------------
        // Emulation functions
        // -------------------------------------------------------------------------
    
        /// @notice Push a value onto the stack
        function push(uint16 val) internal {
            require(emu.sp < STACK_SIZE, "Stack overflow");
            emu.stack[emu.sp] = val;
            emu.sp += 1;
        }
    
        /// @notice Pop a value from the stack
        function pop() internal returns (uint16) {
            require(emu.sp > 0, "Stack underflow");
            emu.sp -= 1;
            return emu.stack[emu.sp];
        }
    
        /// @notice CPU processing loop
        /// @dev This function is called once per tick of the CPU.
        /// Fetch the next instruction, decode and execute it.
        function tick() public {
            // Fetch
            uint16 op = fetch();
            // Decode & execute
            execute(op);

            _tickTimers();
        }

        function _tickTimers() internal {
            if (emu.dt > 0) {
                emu.dt -= 1;
            }

            if (emu.st > 0) {
                if (emu.st == 1) {
                    // BEEP
                }
                emu.st -= 1;
            }
        }
    
        /// @notice Fetch the next instruction
        function fetch() public returns (uint16) {
            require(emu.pc + 1 < RAM_SIZE, "Program counter out of bounds");
            uint16 higher_byte = uint16(emu.ram[emu.pc]);
            uint16 lower_byte = uint16(emu.ram[emu.pc + 1]);
            uint16 op = (higher_byte << 8) | lower_byte;
            emu.pc += 2;
            return op;
        }
    
        function run() public {
            require(emu.program_size > 0, "Program size is 0");
            for (uint256 i = 0; i < emu.program_size; i++) {
                require(emu.pc < RAM_SIZE - 1, "Program counter out of bounds");
                // Fetch the opcode
                uint16 op = fetch();
                // Execute the opcode
                execute(op);
            }
        }
    
        function execute(uint16 op) internal {
            // 0000 - Nop - NOP
            if (op == 0x0000) return;
    
            uint8 digit1 = uint8((op & 0xF000) >> 12);
            uint8 digit2 = uint8((op & 0x0F00) >> 8);
            uint8 digit3 = uint8((op & 0x00F0) >> 4);
            uint8 digit4 = uint8(op & 0x000F);
    
            //  00E0 - CLS
            if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0) {
                for (uint256 i = 0; i < 8; i++) {
                    emu.screen[i] = 0;
                }
                return;
            }
            // 00EE - RET
            else if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0xE) {
                emu.pc = pop();
                return;
            }
            //  1NNN - JMP NNN
            else if (digit1 == 0x1) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = nnn;
                return;
            }
            //  2NNN - CALL NNN
            else if (digit1 == 0x2) {
                uint16 nnn = op & 0x0FFF;
                push(emu.pc);
                emu.pc = nnn;
                return;
            }
            //  3NNN - SKIP VX == NN
            else if (digit1 == 0x3) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] == nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  4NNN - SKIP VX != NN
            else if (digit1 == 0x4) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] != nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  5NNN - SKIP VX == VY
            else if (digit1 == 0x5 && digit4 == 0x0) {
                if (emu.v_reg[digit2] == emu.v_reg[digit3]) {
                    emu.pc += 2;
                }
                return;
            }
            //  6NNN - VX = NN
            else if (digit1 == 0x6) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] = nn;
                return;
            }
            //  7NNN - VX += NN
            else if (digit1 == 0x7) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] += nn;
                return;
            }
            // 8XY0 - VX = VY
            else if (digit1 == 0x8 && digit4 == 0x0) {
                emu.v_reg[digit2] = emu.v_reg[digit3];
                return;
            }
            // 8XY1 - VX |= VY
            else if (digit1 == 0x8 && digit4 == 0x1) {
                emu.v_reg[digit2] |= emu.v_reg[digit3];
                return;
            }
            // 8XY2 - VX &= VY
            else if (digit1 == 0x8 && digit4 == 0x2) {
                emu.v_reg[digit2] &= emu.v_reg[digit3];
                return;
            }
            // 8XY3 - VX ^= VY
            else if (digit1 == 0x8 && digit4 == 0x3) {
                emu.v_reg[digit2] ^= emu.v_reg[digit3];
                return;
            }
            // 8XY4 - VX += VY (with carry)
            else if (digit1 == 0x8 && digit4 == 0x4) {
                uint8 x = digit2;
                uint8 y = digit3;
                uint16 sum = uint16(emu.v_reg[x]) + uint16(emu.v_reg[y]);
                emu.v_reg[0xF] = sum > 0xFF ? 1 : 0;
                emu.v_reg[x] = uint8(sum);
                return;
            }
            // 8XY5 - VX -= VY (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x5) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[x] >= emu.v_reg[y] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] -= emu.v_reg[y];
                }
                return;
            }
            // 8XY6 - VX >>= 1
            else if (digit1 == 0x8 && digit4 == 0x6) {
                uint8 x = digit2;
                emu.v_reg[0xF] = emu.v_reg[x] & 0x1;
                emu.v_reg[x] >>= 1;
                return;
            }
            // 8XY7 - VX = VY - VX (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x7) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[y] >= emu.v_reg[x] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] = emu.v_reg[y] - emu.v_reg[x];
                }
                return;
            }
            // 8XYE - VX <<= 1
            else if (digit1 == 0x8 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.v_reg[0xF] = (emu.v_reg[x] >> 7) & 0x1;
                emu.v_reg[x] <<= 1;
                return;
            }
            // 9XY0 - SKIP VX != VY
            else if (digit1 == 0x9 && digit4 == 0x0) {
                uint8 x = digit2;
                uint8 y = digit3;
                if (emu.v_reg[x] != emu.v_reg[y]) {
                    emu.pc += 2;
                }
                return;
            }
            // ANNN - I = NNN
            else if (digit1 == 0xA) {
                uint16 nnn = op & 0x0FFF;
                emu.i_reg = nnn;
                return;
            }
            // BNNN - PC = V0 + NNN
            else if (digit1 == 0xB) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = uint16(emu.v_reg[0]) + nnn;
                return;
            }
            // CXNN - VX = rand() & NN
            else if (digit1 == 0xC) {
                uint8 x = digit2;
                uint8 nn = uint8(op & 0x00FF);
                // Pseudo-random number generation (not secure)
                uint8 rand =
                    uint8(uint256(keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 1), emu.pc))) % 256);
                emu.v_reg[x] = rand & nn;
                return;
            }
            // DXYN - DRAW
            else if (digit1 == 0xD) {
                uint8 x = emu.v_reg[digit2] % uint8(SCREEN_WIDTH);
                uint8 y = emu.v_reg[digit3] % uint8(SCREEN_HEIGHT);
                uint8 height = digit4;
                emu.v_reg[0xF] = 0; // Reset VF
    
                for (uint8 row = 0; row < height; row++) {
                    uint8 sprite_byte = emu.ram[emu.i_reg + row];
                    for (uint8 col = 0; col < 8; col++) {
                        // Get the sprite pixel (bit) at the current column
                        uint8 sprite_pixel = (sprite_byte >> (7 - col)) & 0x1;
    
                        // Calculate the screen coordinates, wrapping around if necessary
                        uint32 screen_x = uint32((x + col) % SCREEN_WIDTH);
                        uint32 screen_y = uint32((y + row) % SCREEN_HEIGHT);
    
                        // Calculate the index in the display buffer
                        uint32 pixel_index = screen_y * SCREEN_WIDTH + screen_x; // Range: 0 to 2047
    
                        // Calculate the display array index and bit position
                        uint256 display_index = pixel_index / 256; // Index in emu.screen[]
                        uint256 bit_position = pixel_index % 256; // Bit position within emu.screen[display_index]
    
                        // Get the current pixel value from the display
                        bool pixel_before = ((emu.screen[display_index] >> (255 - bit_position)) & 0x1) != 0;
    
                        // Calculate the new pixel value using XOR (as per CHIP-8 drawing behavior)
                        bool new_pixel = pixel_before != (sprite_pixel == 1);
    
                        // Update the collision flag VF if a pixel is erased
                        if (pixel_before && !new_pixel) {
                            emu.v_reg[0xF] = 1;
                        }
    
                        // Update the display with the new pixel value
                        if (new_pixel) {
                            // Set the bit to 1
                            emu.screen[display_index] |= (1 << (255 - bit_position));
                        } else {
                            // Set the bit to 0
                            emu.screen[display_index] &= ~(1 << (255 - bit_position));
                        }
                    }
                }
                return;
            }
            // EX9E - SKIP if key[VX] pressed
            else if (digit1 == 0xE && digit3 == 0x9 && digit4 == 0xE) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if (emu.keys[key]) {
                    emu.pc += 2;
                }
                return;
            }
            // EXA1 - SKIP if key[VX] not pressed
            else if (digit1 == 0xE && digit3 == 0xA && digit4 == 0x1) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if (!emu.keys[key]) {
                    emu.pc += 2;
                }
                return;
            }
            // FX07 - VX = DT
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0x7) {
                uint8 x = digit2;
                emu.v_reg[x] = emu.dt;
                return;
            }
            // FX0A - Wait for key press
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0xA) {
                uint8 x = digit2;
                bool key_pressed = false;
                for (uint8 i = 0; i < NUM_KEYS; i++) {
                    if (emu.keys[i]) {
                        emu.v_reg[x] = i;
                        key_pressed = true;
                        break;
                    }
                }
                if (!key_pressed) {
                    // Repeat this opcode
                    emu.pc -= 2;
                }
                return;
            }
            // FX15 - DT = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x5) {
                uint8 x = digit2;
                emu.dt = emu.v_reg[x];
                return;
            }
            // FX18 - ST = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x8) {
                uint8 x = digit2;
                emu.st = emu.v_reg[x];
                return;
            }
            // FX1E - I += VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.i_reg += uint16(emu.v_reg[x]);
                return;
            }
            // FX29 - I = location of sprite for digit VX
            else if (digit1 == 0xF && digit3 == 0x2 && digit4 == 0x9) {
                uint8 x = digit2;
                uint8 digit = emu.v_reg[x];
                emu.i_reg = uint16(digit) * 5; // Each sprite is 5 bytes
                return;
            }
            // FX33 - Store BCD representation of VX in memory locations I, I+1, and I+2
            else if (digit1 == 0xF && digit3 == 0x3 && digit4 == 0x3) {
                uint8 x = digit2;
                uint8 value = emu.v_reg[x];
                emu.ram[emu.i_reg] = value / 100;
                emu.ram[emu.i_reg + 1] = (value / 10) % 10;
                emu.ram[emu.i_reg + 2] = value % 10;
                return;
            }
            // FX55 - Store V0 to VX in memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x5 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.ram[emu.i_reg + i] = emu.v_reg[i];
                }
                return;
            }
            // FX65 - Read V0 to VX from memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x6 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.v_reg[i] = emu.ram[emu.i_reg + i];
                }
                return;
            } else {
                revert("Opcode not implemented");
            }
        }
    
        // -------------------------------------------------------------------------
        // Frontend functions
        // -------------------------------------------------------------------------
    
        /// @notice Get display
        function getDisplay() public view returns (uint256[8] memory) {
            return emu.screen;
        }
    
        /// @notice Handle keypress event
        function keypress(uint256 idx, bool pressed) public {
            require(idx < NUM_KEYS, "Invalid key index");
            emu.keys[idx] = pressed;
        }
    
        /// @notice Load program into memory
        function load(uint8[] memory data) public {
            uint256 start = START_ADDR;
            uint256 end = START_ADDR + data.length;
            require(end <= RAM_SIZE, "Data too large to fit in RAM");
            for (uint256 i = start; i < end; i++) {
                emu.ram[i] = data[i - start];
            }
            emu.program_size = data.length;
        }
    
        // -------------------------------------------------------------------------
        // Utility functions
        // -------------------------------------------------------------------------
    
        function getPC() public view returns (uint16) {
            return emu.pc;
        }

        function getKeys() public view returns(bool[16] memory){
            return emu.keys;
        }
    
        function getRAMValueAt(uint256 index) public view returns (uint8) {
            require(index < RAM_SIZE, "RAM index out of bounds");
            return emu.ram[index];
        }
    
        function getVRegister(uint256 index) public view returns (uint8) {
            require(index < NUM_REGS, "V register index out of bounds");
            return emu.v_reg[index];
        }
    
        function setVRegister(uint8 index, uint8 value) public {
            require(index < NUM_REGS, "V register index out of bounds");
            emu.v_reg[index] = value;
        }
    
        function getIRegister() public view returns (uint16) {
            return emu.i_reg;
        }
    
        function setIRegister(uint16 value) public {
            emu.i_reg = value;
        }
    
        function setRAMValueAt(uint256 index, uint8 value) public {
            require(index < RAM_SIZE, "RAM index out of bounds");
            emu.ram[index] = value;
        }
    
        function getDelayTimer() public view returns (uint8) {
            return emu.dt;
        }
    
        function setDelayTimer(uint8 value) public {
            emu.dt = value;
        }
    
        function getSoundTimer() public view returns (uint8) {
            return emu.st;
        }
    
        function setSoundTimer(uint8 value) public {
            emu.st = value;
        }
    
        function getSP() public view returns (uint16) {
            return emu.sp;
        }
    
        function getStackValue(uint256 index) public view returns (uint16) {
            require(index < STACK_SIZE, "Stack index out of bounds");
            return emu.stack[index];
        }
    
        function setStackValue(uint256 index, uint16 value) public {
            require(index < STACK_SIZE, "Stack index out of bounds");
            emu.stack[index] = value;
        }
    
        function setSP(uint16 value) public {
            emu.sp = value;
        }
    
        function setScreenPixel(uint256 index, bool value) public {
            unchecked {
                require(index < SCREEN_WIDTH * SCREEN_HEIGHT, "Index out of bounds");
                if (value) {
                    // Set the bit to 1
                    emu.screen[index >> 8] |= 1 << (index & 255);
                } else {
                    // Set the bit to 0
                    emu.screen[index >> 8] &= ~(1 << (index & 255));
                }
            }
        }
    
        function isDisplayCleared() public view returns (bool) {
            return (
                emu.screen[0] == 0 && emu.screen[1] == 0 && emu.screen[2] == 0 && emu.screen[3] == 0 && emu.screen[4] == 0
                    && emu.screen[5] == 0 && emu.screen[6] == 0 && emu.screen[7] == 0
            );
        }
    }    
}

#[tokio::main]
async fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: cargo run path/to/game");
        return;
    }

    // Setup SDL
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let window = video_subsystem
        .window("Chip-8 Emulator", WINDOW_WIDTH, WINDOW_HEIGHT)
        .position_centered()
        .opengl()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    canvas.clear();
    canvas.present();
    let mut event_pump = sdl_context.event_pump().unwrap();
    // testing anvil account
    let signer: PrivateKeySigner = PrivateKeySigner::from_str(
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    )
    .unwrap();
    let wallet = EthereumWallet::from(signer);

    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(Url::from_str("http://localhost:8545").unwrap());

    // Get node info using the Anvil API.
    let info = provider.anvil_node_info().await.unwrap();

    println!("Node info: {:#?}", info);

    let chip8 = Emu::deploy(&provider).await.unwrap();
    // commented out, address that deployed on sepolia
    // let address = Address::from_str("0x8494dba7A8958629fE3e55D8F7F5eAF22978a467").unwrap();
    // let chip8 = Emu::new(address, &provider);

    let mut rom = File::open(&args[1]).expect("Unable to open file");
    let mut buffer = Vec::new();

    rom.read_to_end(&mut buffer).unwrap();
    println!("Loaded ROM with {:?} bytes", buffer);
    let builder = chip8.load(buffer.to_vec());
    builder.call().await.unwrap();
    // 250ms
    let tx = builder.send().await.unwrap().get_receipt().await.unwrap();
    println!("load tx: {:?}", tx);
    let r = chip8.getRAMValueAt(U256::from(512)).call().await.unwrap();
    // Check loaded successfully
    assert_eq!(r._0, buffer[0]);

    'gameloop: loop {
        let now = std::time::Instant::now();
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::Escape),
                    ..
                } => {
                    break 'gameloop;
                }
                Event::KeyDown {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), true);
                        builder.call().await.unwrap();

                        let keys = chip8.getKeys().call().await.unwrap();
                        println!("keys: {:?}", keys._0);

                        if !keys._0[k]{
                            let tx = builder.send().await.unwrap();
                            println!("⭐️ key {:?} down tx: {:?}", key, tx);
                        }
                      
                    }
                }
                Event::KeyUp {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), false);
                        builder.call().await.unwrap();

                        let keys = chip8.getKeys().call().await.unwrap();
                        println!("keys: {:?}", keys._0);

                        if keys._0[k]{
                            let tx = builder.send().await.unwrap();
                            println!("⭐️ key {:?} up tx: {:?}", key, tx);
                        }
                    }
                }
                _ => (),
            }
        }

        // TODO: I want to have tick per frame
        // for _ in 0..TICKS_PER_FRAME {}
        let builder = chip8.tick();
        builder.call().await.unwrap();
       
        let tx = builder.send().await.unwrap();
        println!("tx:{:?}", tx);

        let pc = chip8.getPC().call().await.unwrap();
        println!("PC: {:?}", pc._0);

        let keys = chip8.getKeys().call().await.unwrap();
        println!("keys: {:?}", keys._0);

        let dt = chip8.getDelayTimer().call().await.unwrap();
        println!("DT: {:?}", dt._0);
     
        draw_screen(&chip8, &mut canvas).await;

        let end = std::time::Instant::now();
        println!("⌛️ duration :{:?}", end.duration_since(now));
    }
}

async fn draw_screen<T, P, N>(emu: &EmuInstance<T, P, N>, canvas: &mut Canvas<Window>)
where
    T: Transport + Clone,
    P: Provider<T, N>,
    N: Network,
{
    // Clear canvas as black
    canvas.set_draw_color(Color::RGB(0, 0, 0));
    canvas.clear();

    let builder = emu.getDisplay();
    let screen_buf = builder.call().await.unwrap()._0;

    // Now set draw color to white, iterate through each point and see if it should be drawn
    canvas.set_draw_color(Color::RGB(255, 255, 255));
    for (i, pixel) in screen_buf.iter().enumerate() {
        let pixel_bytes:[u8; 32]  = pixel.to_be_bytes();
        for (j, pixel_byte) in pixel_bytes.into_iter().enumerate() {
            let pixel_bits = pixel_byte.view_bits::<Msb0>();
            for (k, pixel_bit) in pixel_bits.into_iter().enumerate() {
                if *pixel_bit {
                    let index= k + (j * 8) + (i * 256);
                    // println!("index:{:?}", index);
                    // Convert our 1D array's index into a 2D (x,y) position
                    let x = (index % SCREEN_WIDTH) as u32;
                    let y = (index / SCREEN_WIDTH) as u32;
        
                    // Draw a rectangle at (x,y), scaled up by our SCALE value
                    let rect = Rect::new((x * SCALE) as i32, (y * SCALE) as i32, SCALE, SCALE);
                    canvas.fill_rect(rect).unwrap();
                }
            }
        }
       
    }
    canvas.present();
}

/*
    Keyboard                    Chip-8
    +---+---+---+---+           +---+---+---+---+
    | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 | C |
    +---+---+---+---+           +---+---+---+---+
    | Q | W | E | R |           | 4 | 5 | 6 | D |
    +---+---+---+---+     =>    +---+---+---+---+
    | A | S | D | F |           | 7 | 8 | 9 | E |
    +---+---+---+---+           +---+---+---+---+
    | Z | X | C | V |           | A | 0 | B | F |
    +---+---+---+---+           +---+---+---+---+
*/

fn key2btn(key: Keycode) -> Option<usize> {
    match key {
        Keycode::Num1 => Some(0x1),
        Keycode::Num2 => Some(0x2),
        Keycode::Num3 => Some(0x3),
        Keycode::Num4 => Some(0xC),
        Keycode::Q => Some(0x4),
        Keycode::W => Some(0x5),
        Keycode::E => Some(0x6),
        Keycode::R => Some(0xD),
        Keycode::A => Some(0x7),
        Keycode::S => Some(0x8),
        Keycode::D => Some(0x9),
        Keycode::F => Some(0xE),
        Keycode::Z => Some(0xA),
        Keycode::X => Some(0x0),
        Keycode::C => Some(0xB),
        Keycode::V => Some(0xF),
        _ => None,
    }
}
