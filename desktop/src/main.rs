//! code is credit from https://github.com/aquova/chip8-book/tree/master/code/desktop

use std::env;
use std::fs::File;
use std::io::Read;
use std::str::FromStr;
use bitvec::prelude::*;

use alloy::network::{EthereumWallet, Network};
use alloy::primitives::U256;
use alloy::providers::ext::AnvilApi;
use alloy::providers::{Provider, ProviderBuilder};
use alloy::signers::local::PrivateKeySigner;
use alloy::sol;
use alloy::transports::http::reqwest::Url;
use alloy::transports::Transport;
use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::rect::Rect;
use sdl2::render::Canvas;
use sdl2::video::Window;
use Solchip8::Solchip8Instance;

const SCREEN_WIDTH: usize = 64;
const SCREEN_HEIGHT: usize = 32;
const SCALE: u32 = 15;
const WINDOW_WIDTH: u32 = (SCREEN_WIDTH as u32) * SCALE;
const WINDOW_HEIGHT: u32 = (SCREEN_HEIGHT as u32) * SCALE;
// const TICKS_PER_FRAME: usize = 5;

sol! {
    #[sol(rpc, bytecode="0x610a80604090815260f06080818152609060a081905260c081905260e0818152610100849052602061012081905260606101405261016081905261018081905260706101a0526101c085905260106101e08190526102008690526102208590526102408690526102608690526102808190526102a08690526102c08190526102e08690526103008490526103208490526103408690526103608190526103808190526103a08690526103c08590526103e08690526104008190526104208690526104408690526104608590526104808690526104a08490526104c08690526104e086905261050081905261052091909152610540869052610560959095526105808490526105a08290526105c08490526105e0829052610600849052610620849052610640829052610660849052610680949094526106a08390526106c08390526106e08190526107008390526107208190526107408190526107608490526107808190526107a08490526107c08190526107e08490526108008390526108208290526108408290526108608290526108808390526108a08490526108c08190526108e081905261090052610920929092526109408190526109608290526109808190526109a08290526109c08190526109e0819052610a00829052610a2052610a40819052610a608190526101f9906000906050610292565b5034801561020657600080fd5b506003805461ffff191661020017905560005b605081101561028c57600081605081106102355761023561033a565b602081049091015460ff601f9092166101000a900416600482611000811061025f5761025f61033a565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610219565b50610350565b6003830191839082156103155791602002820160005b838211156102e657835183826101000a81548160ff021916908360ff16021790555092602001926001016020816000010492830192600103026102a8565b80156103135782816101000a81549060ff02191690556001016020816000010492830192600103026102e6565b505b50610321929150610325565b5090565b5b808211156103215760008155600101610326565b634e487b7160e01b600052603260045260246000fd5b6129958061035f6000396000f3fe608060405234801561001057600080fd5b50600436106101735760003560e01c8063997a40c0116100de578063ae344f8e11610097578063d19dc8b511610071578063d19dc8b514610353578063d2bf2e1c1461035f578063d826f88f1461038b578063e781d8c51461039357600080fd5b8063ae344f8e14610326578063c040622614610338578063cbc950191461034057600080fd5b8063997a40c0146102bc5780639cba24bb146102cf578063a560ea3b146102e7578063a72b6604146102fa578063a8b3ac781461030d578063a95c372d1461031e57600080fd5b80637ef91424116101305780637ef914241461022d57806380bc398e146102425780638153da0314610255578063825284fd146102685780638c41bd001461027b57806392ddeea0146102a957600080fd5b80632150c518146101785780632f57e5f7146101985780633eaf5d9f146101c85780636398efc8146101d057806366050ab9146101f557806368ad83f11461021b575b600080fd5b608f5461ffff165b60405161ffff90911681526020015b60405180910390f35b6101c66101a6366004612514565b608d805461ffff909216620100000263ffff000019909216919091179055565b005b6101c661039f565b6101e36101de366004612536565b6103bf565b60405160ff909116815260200161018f565b6101c6610203366004612514565b608d805461ffff191661ffff92909216919091179055565b608d5462010000900461ffff16610180565b610235610441565b60405161018f919061254f565b6101c6610250366004612581565b61047d565b6101c66102633660046125dd565b61051d565b6101c66102763660046126ad565b6105ff565b6101c66102893660046126d9565b608f805460ff90921663010000000263ff00000019909216919091179055565b6101c66102b73660046126f4565b610683565b6101c66102ca366004612717565b61070c565b6102d7610776565b604051901515815260200161018f565b6101e36102f5366004612536565b6107d6565b610180610308366004612536565b61083b565b608f5462010000900460ff166101e3565b6101806108bd565b608f546301000000900460ff166101e3565b6101c66109ef565b6101c661034e366004612581565b610ac2565b608d5461ffff16610180565b6101c661036d3660046126d9565b608f805460ff909216620100000262ff000019909216919091179055565b6101c6610b49565b60035461ffff16610180565b60006103a96108bd565b90506103b481610cb7565b6103bc6122ad565b50565b600061100082106104115760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b60448201526064015b60405180910390fd5b600482611000811061042557610425612741565b602081049091015460ff601f9092166101000a90041692915050565b6104496124de565b604080516101008101918290529060849060089082845b815481526020019060010190808311610460575050505050905090565b61080082106104c45760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b6044820152606401610408565b80156104f357600160ff83161b6084600884811c9081106104e7576104e7612741565b01805490911790555050565b600160ff83161b196084600884811c90811061051157610511612741565b01805490911690555050565b805161020090600090610530908361276d565b90506110008111156105845760405162461bcd60e51b815260206004820152601c60248201527f4461746120746f6f206c6172676520746f2066697420696e2052414d000000006044820152606401610408565b815b818110156105f557836105998483612786565b815181106105a9576105a9612741565b602002602001015160036001018261100081106105c8576105c8612741565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610586565b5050905160905550565b611000821061064a5760405162461bcd60e51b815260206004820152601760248201527652414d20696e646578206f7574206f6620626f756e647360481b6044820152606401610408565b80600483611000811061065f5761065f612741565b602091828204019190066101000a81548160ff021916908360ff1602179055505050565b601082106106cf5760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b6044820152606401610408565b80608e83601081106106e3576106e3612741565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055505050565b601060ff83161061075f5760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e647300006044820152606401610408565b80608c60ff84166010811061065f5761065f612741565b6084546000901580156107895750608554155b80156107955750608654155b80156107a15750608754155b80156107ad5750608854155b80156107b95750608954155b80156107c55750608a54155b80156107d15750608b54155b905090565b6000601082106108285760405162461bcd60e51b815260206004820152601e60248201527f5620726567697374657220696e646578206f7574206f6620626f756e647300006044820152606401610408565b608c826010811061042557610425612741565b6000601082106108895760405162461bcd60e51b8152602060048201526019602482015278537461636b20696e646578206f7574206f6620626f756e647360381b6044820152606401610408565b608e826010811061089c5761089c612741565b601091828204019190066002029054906101000a900461ffff169050919050565b600354600090611000906108d69061ffff166001612799565b61ffff16106109275760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e64730000006044820152606401610408565b60035460009060049061ffff16611000811061094557610945612741565b602081049190910154600354601f9092166101000a900460ff1691506000906004906109769061ffff166001612799565b61ffff16611000811061098b5761098b612741565b60208104919091015460038054601f9093166101000a90910460ff169250600884901b62ffff0016831791600291906000906109cc90849061ffff16612799565b92506101000a81548161ffff021916908361ffff16021790555080935050505090565b609054610a325760405162461bcd60e51b8152602060048201526011602482015270050726f6772616d2073697a65206973203607c1b6044820152606401610408565b60005b6090548110156103bc57610a4c60016110006127b3565b60035461ffff918216911610610aa45760405162461bcd60e51b815260206004820152601d60248201527f50726f6772616d20636f756e746572206f7574206f6620626f756e64730000006044820152606401610408565b6000610aae6108bd565b9050610ab981610cb7565b50600101610a35565b60108210610b065760405162461bcd60e51b8152602060048201526011602482015270092dcecc2d8d2c840d6caf240d2dcc8caf607b1b6044820152606401610408565b8015610b2b57608f805461ffff6001851b81169082161761ffff199091161790555050565b608f805461ffff1981166001851b199190911661ffff161790555050565b6003805461ffff191661020017905560005b6008811015610b8357600060848260088110610b7957610b79612741565b0155600101610b5b565b5060005b6010811015610bd2576000608c8260108110610ba557610ba5612741565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610b87565b50608d805463ffffffff1916905560005b6010811015610c33576000608e8260108110610c0157610c01612741565b601091828204019190066002026101000a81548161ffff021916908361ffff1602179055508080600101915050610be3565b50608f805463ffffffff1916905560005b60508110156103bc5760008160508110610c6057610c60612741565b602081049091015460ff601f9092166101000a9004166004826110008110610c8a57610c8a612741565b602091828204019190066101000a81548160ff021916908360ff1602179055508080600101915050610c44565b8061ffff16600003610cc65750565b600f600c82901c811690600883901c811690600484901c811690841683158015610cf1575060ff8316155b8015610d0057508160ff16600e145b8015610d0d575060ff8116155b15610d455760005b6008811015610d3d57600060848260088110610d3357610d33612741565b0155600101610d15565b505050505050565b60ff8416158015610d57575060ff8316155b8015610d6657508160ff16600e145b8015610d7557508060ff16600e145b15610d9f57610d82612343565b6003805461ffff191661ffff929092169190911790555050505050565b8360ff16600103610dc65750506003805461ffff1916610fff909416939093179092555050565b8360ff16600203610de757600354610fff861690610d829061ffff16612409565b8360ff16600303610e665760ff808616908190608c90861660108110610e0f57610e0f612741565b602081049091015460ff601f9092166101000a90041603610d3d576003805460029190600090610e4490849061ffff16612799565b92506101000a81548161ffff021916908361ffff160217905550505050505050565b8360ff16600403610ec35760ff808616908190608c90861660108110610e8e57610e8e612741565b602081049091015460ff601f9092166101000a90041614610d3d576003805460029190600090610e4490849061ffff16612799565b8360ff166005148015610ed7575060ff8116155b15610f7657608c60ff831660108110610ef257610ef2612741565b602081049091015460ff601f9092166101000a9004811690608c90851660108110610f1f57610f1f612741565b602081049091015460ff601f9092166101000a90041603610f6f576003805460029190600090610f5490849061ffff16612799565b92506101000a81548161ffff021916908361ffff1602179055505b5050505050565b8360ff16600603610fc65760ff808616908190608c90861660108110610f9e57610f9e612741565b602091828204019190066101000a81548160ff021916908360ff160217905550505050505050565b8360ff166007036110215760ff808616908190608c90861660108110610fee57610fee612741565b60208104909101805460ff601f9093166101000a8082048416909401831684029290930219909216179055505050505050565b8360ff166008148015611035575060ff8116155b156110a457608c60ff83166010811061105057611050612741565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061107d5761107d612741565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050565b8360ff1660081480156110ba57508060ff166001145b1561113b57608c60ff8316601081106110d5576110d5612741565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061110257611102612741565b602091828204019190068282829054906101000a900460ff161792506101000a81548160ff021916908360ff1602179055505050505050565b8360ff16600814801561115157508060ff166002145b156111cb57608c60ff83166010811061116c5761116c612741565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061119957611199612741565b602081049091018054601f9092166101000a80830490931660ff90811684029302199091169190911790555050505050565b8360ff1660081480156111e157508060ff166003145b1561125b57608c60ff8316601081106111fc576111fc612741565b602081049091015460ff601f9092166101000a9004811690608c9085166010811061122957611229612741565b60208104909101805460ff601f9093166101000a80820484169094188316840292909302199092161790555050505050565b8360ff16600814801561127157508060ff166004145b1561134b5782826000608c60ff83166010811061129057611290612741565b602081049091015460ff601f9092166101000a9004811690608c908516601081106112bd576112bd612741565b6020810491909101546112dc9291601f166101000a900460ff16612799565b905060ff8161ffff16116112f15760006112f4565b60015b608c805460ff60781b1916600160781b60ff93841602178155829185166010811061132157611321612741565b602091828204019190066101000a81548160ff021916908360ff1602179055505050505050505050565b8360ff16600814801561136157508060ff166005145b1561145f578282608c60ff82166010811061137e5761137e612741565b602081049091015460ff601f9092166101000a9004811690608c908416601081106113ab576113ab612741565b602081049091015460ff601f9092166101000a90041610156113ce5760006113d1565b60015b608c805460ff60781b1916600160781b60ff93841602178155908216601081106113fd576113fd612741565b602081049091015460ff601f9092166101000a9004811690608c9084166010811061142a5761142a612741565b60208104909101805460ff601f9093166101000a80820484169490940383168402929093021990921617905550505050505050565b8360ff16600814801561147557508060ff166006145b156115085782608c60ff82166010811061149157611491612741565b602081049190910154608c805460ff60781b19166001601f9094166101000a9092048316600160781b0291909117815560ff8316601081106114d5576114d5612741565b60208104909101805460ff601f9093166101000a808204841690941c831684029290930219909216179055505050505050565b8360ff16600814801561151e57508060ff166007145b15611640578282608c60ff83166010811061153b5761153b612741565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061156857611568612741565b602081049091015460ff601f9092166101000a900416101561158b57600061158e565b60015b608c805460ff60781b1916600160781b60ff93841602178155908316601081106115ba576115ba612741565b602081049091015460ff601f9092166101000a9004811690608c908316601081106115e7576115e7612741565b602091828204019190069054906101000a900460ff160360036089018360ff166010811061161757611617612741565b602091828204019190066101000a81548160ff021916908360ff16021790555050505050505050565b8360ff16600814801561165657508060ff16600e145b156116f457826007608c60ff83166010811061167457611674612741565b602081049190910154608c805460ff60781b1916601f9093166101000a90910460ff90811690931c6001908116600160781b0292909217815590918316601081106116c1576116c1612741565b60208104909101805460ff601f9093166101000a808204841690941b831684029290930219909216179055505050505050565b8360ff166009148015611708575060ff8116155b156117ab578282608c60ff82166010811061172557611725612741565b602081049091015460ff601f9092166101000a9004811690608c9084166010811061175257611752612741565b602081049091015460ff601f9092166101000a900416146117a257600380546002919060009061178790849061ffff16612799565b92506101000a81548161ffff021916908361ffff1602179055505b50505050505050565b8360ff16600a036117d2575050608d805461ffff1916610fff909416939093179092555050565b8360ff16600b0361181257608c54610fff8616906117f490829060ff16612799565b6003805461ffff191661ffff92909216919091179055505050505050565b8360ff16600c036118a9578260ff8616600061010042611833600143612786565b60035460405161186b9392409161ffff1690602001928352602083019190915260f01b6001600160f01b031916604082015260420190565b6040516020818303038152906040528051906020012060001c61188e91906127e3565b9050818116608c60ff85166010811061132157611321612741565b8360ff16600d03611b2c5760006040608c60ff8616601081106118ce576118ce612741565b602091828204019190069054906101000a900460ff166118ee91906127f7565b905060006020608c60ff86166010811061190a5761190a612741565b602091828204019190069054906101000a900460ff1661192a91906127f7565b608c805460ff60781b1916905590508260005b8160ff168160ff161015611b2157608d546000906004906119669060ff85169061ffff16612799565b61ffff16611000811061197b5761197b612741565b602081049091015460ff601f9092166101000a900416905060005b60088160ff161015611b175760006119af826007612819565b60ff168360ff16901c60011690506000604083896119cd9190612832565b60ff166119da919061284b565b61ffff169050600060206119ee878a612832565b60ff166119fb919061284b565b61ffff169050600082611a0f60408461286f565b611a199190612895565b90506000611a29610100836128b1565b63ffffffff1690506000611a3f610100846128d9565b63ffffffff1690506000611a548260ff612786565b60848460088110611a6757611a67612741565b01546001911c8116158015925060ff8916909114821415908290611a89575080155b15611aa257608c805460ff60781b1916600160781b1790555b8015611ad757611ab38360ff612786565b6001901b60848560088110611aca57611aca612741565b0180549091179055611b03565b611ae28360ff612786565b6001901b1960848560088110611afa57611afa612741565b01805490911690555b505060019096019550611996945050505050565b505060010161193d565b505050505050505050565b8360ff16600e148015611b4257508160ff166009145b8015611b5157508060ff16600e145b15611bf357826000608c60ff831660108110611b6f57611b6f612741565b602081049091015460ff601f9092166101000a900416905060108110611bc55760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b6044820152606401610408565b608f54600160ff83161b1661ffff16156117a257600380546002919060009061178790849061ffff16612799565b8360ff16600e148015611c0957508160ff16600a145b8015611c1857508060ff166001145b15611cbc57826000608c60ff831660108110611c3657611c36612741565b602081049091015460ff601f9092166101000a900416905060108110611c8c5760405162461bcd60e51b815260206004820152600b60248201526a496e76616c6964206b657960a81b6044820152606401610408565b608f54600160ff83161b1661ffff166000036117a257600380546002919060009061178790849061ffff16612799565b8360ff16600f148015611cd0575060ff8216155b8015611cdf57508060ff166007145b15611d0a57608f54839060ff62010000909104811690608c90831660108110610f9e57610f9e612741565b8360ff16600f148015611d1e575060ff8216155b8015611d2d57508060ff16600a145b15611dbf57826000805b601060ff82161015611d9f57608f54600160ff83161b1661ffff1615611d975780608c60ff851660108110611d6e57611d6e612741565b602091828204019190066101000a81548160ff021916908360ff16021790555060019150611d9f565b600101611d37565b50806117a257600380546002919060009061178790849061ffff166127b3565b8360ff16600f148015611dd557508160ff166001145b8015611de457508060ff166005145b15611e355782608c60ff821660108110611e0057611e00612741565b602081049190910154608f805462ff00001916601f9093166101000a90910460ff166201000002919091179055505050505050565b8360ff16600f148015611e4b57508160ff166001145b8015611e5a57508060ff166008145b15611ead5782608c60ff821660108110611e7657611e76612741565b602081049190910154608f805463ff0000001916601f9093166101000a90910460ff16630100000002919091179055505050505050565b8360ff16600f148015611ec357508160ff166001145b8015611ed257508060ff16600e145b15611f1d5782608c60ff821660108110611eee57611eee612741565b602081049190910154608d8054601f9093166101000a90910460ff1691600090610e4490849061ffff16612799565b8360ff16600f148015611f3357508160ff166002145b8015611f4257508060ff166009145b15611fa257826000608c60ff831660108110611f6057611f60612741565b602081049091015460ff601f9092166101000a9004169050611f83816005612901565b608d805461ffff191661ffff9290921691909117905550505050505050565b8360ff16600f148015611fb857508160ff166003145b8015611fc757508060ff166003145b156120dc57826000608c60ff831660108110611fe557611fe5612741565b602081049091015460ff601f9092166101000a900416905061200860648261291e565b608d5460049061ffff16611000811061202357612023612741565b602091828204019190066101000a81548160ff021916908360ff160217905550600a8082612051919061291e565b61205b91906127f7565b608d546004906120709061ffff166001612799565b61ffff16611000811061208557612085612741565b602091828204019190066101000a81548160ff021916908360ff160217905550600a816120b291906127f7565b608d546004906120c79061ffff166002612799565b61ffff16611000811061161757611617612741565b8360ff16600f1480156120f257508160ff166005145b801561210157508060ff166005145b156121a4578260005b8160ff168160ff16116117a257608c60ff82166010811061212d5761212d612741565b6020810490910154608d5460ff601f9093166101000a90910482169160049161215c9185169061ffff16612799565b61ffff16611000811061217157612171612741565b602091828204019190066101000a81548160ff021916908360ff160217905550808061219c90612940565b91505061210a565b8360ff16600f1480156121ba57508160ff166006145b80156121c957508060ff166005145b1561226c578260005b8160ff168160ff16116117a257608d546004906121f79060ff84169061ffff16612799565b61ffff16611000811061220c5761220c612741565b602081049091015460ff601f9092166101000a9004811690608c9083166010811061223957612239612741565b602091828204019190066101000a81548160ff021916908360ff160217905550808061226490612940565b9150506121d2565b60405162461bcd60e51b815260206004820152601660248201527513dc18dbd919481b9bdd081a5b5c1b195b595b9d195960521b6044820152606401610408565b608f5462010000900460ff16156122f657608f8054600191906002906122dd90849062010000900460ff16612819565b92506101000a81548160ff021916908360ff1602179055505b608f546301000000900460ff161561234157608f8054600191906003906123289084906301000000900460ff16612819565b92506101000a81548160ff021916908360ff1602179055505b565b608d5460009062010000900461ffff166123915760405162461bcd60e51b815260206004820152600f60248201526e537461636b20756e646572666c6f7760881b6044820152606401610408565b608d8054600191906002906123b190849062010000900461ffff166127b3565b82546101009290920a61ffff818102199093169183160217909155608d54608e925062010000900416601081106123ea576123ea612741565b601091828204019190066002029054906101000a900461ffff16905090565b608d5460106201000090910461ffff16106124575760405162461bcd60e51b815260206004820152600e60248201526d537461636b206f766572666c6f7760901b6044820152606401610408565b608d548190608e9062010000900461ffff166010811061247957612479612741565b601091828204019190066002026101000a81548161ffff021916908361ffff16021790555060016003608a0160028282829054906101000a900461ffff166124c19190612799565b92506101000a81548161ffff021916908361ffff16021790555050565b6040518061010001604052806008906020820280368337509192915050565b803561ffff8116811461250f57600080fd5b919050565b60006020828403121561252657600080fd5b61252f826124fd565b9392505050565b60006020828403121561254857600080fd5b5035919050565b6101008101818360005b6008811015612578578151835260209283019290910190600101612559565b50505092915050565b6000806040838503121561259457600080fd5b82359150602083013580151581146125ab57600080fd5b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b803560ff8116811461250f57600080fd5b6000602082840312156125ef57600080fd5b813567ffffffffffffffff81111561260657600080fd5b8201601f8101841361261757600080fd5b803567ffffffffffffffff811115612631576126316125b6565b8060051b604051601f19603f830116810181811067ffffffffffffffff8211171561265e5761265e6125b6565b60405291825260208184018101929081018784111561267c57600080fd5b6020850194505b838510156126a257612694856125cc565b815260209485019401612683565b509695505050505050565b600080604083850312156126c057600080fd5b823591506126d0602084016125cc565b90509250929050565b6000602082840312156126eb57600080fd5b61252f826125cc565b6000806040838503121561270757600080fd5b823591506126d0602084016124fd565b6000806040838503121561272a57600080fd5b612733836125cc565b91506126d0602084016125cc565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561278057612780612757565b92915050565b8181038181111561278057612780612757565b61ffff818116838216019081111561278057612780612757565b61ffff828116828216039081111561278057612780612757565b634e487b7160e01b600052601260045260246000fd5b6000826127f2576127f26127cd565b500690565b600060ff83168061280a5761280a6127cd565b8060ff84160691505092915050565b60ff828116828216039081111561278057612780612757565b60ff818116838216019081111561278057612780612757565b600061ffff83168061285f5761285f6127cd565b8061ffff84160691505092915050565b63ffffffff818116838216029081169081811461288e5761288e612757565b5092915050565b63ffffffff818116838216019081111561278057612780612757565b600063ffffffff8316806128c7576128c76127cd565b8063ffffffff84160491505092915050565b600063ffffffff8316806128ef576128ef6127cd565b8063ffffffff84160691505092915050565b61ffff818116838216029081169081811461288e5761288e612757565b600060ff831680612931576129316127cd565b8060ff84160491505092915050565b600060ff821660ff810361295657612956612757565b6001019291505056fea26469706673582212208783501ad6ba54155d942d2b9f64cc392cb261e876d944862720d5ab983aa57964736f6c634300081c0033")]
    contract Solchip8 {
        // -------------------------------------------------------------------------
        // Constants
        // -------------------------------------------------------------------------
    
        /// @notice Screen width in pixels.
        uint16 constant SCREEN_WIDTH = 64;
        /// @notice Screen height in pixels.
        uint16 constant SCREEN_HEIGHT = 32;
    
        /// @notice Size of RAM in bytes.
        uint16 constant RAM_SIZE = 4096;
        /// @notice Number of general-purpose registers.
        uint8 constant NUM_REGS = 16;
        /// @notice Number of stack entries.
        uint8 constant STACK_SIZE = 16;
        /// @notice Number of keys on the CHIP-8 keyboard.
        uint8 constant NUM_KEYS = 16;
    
        // -------------------------------------------------------------------------
        // Display
        // -------------------------------------------------------------------------
    
        /// @notice Size of the font set.
        uint8 constant FONTSET_SIZE = 80;
    
        /// @notice Font set containing the sprite data for hexadecimal digits (0-9 and A-F).
        /// @dev Each character sprite consists of 5 bytes, representing an 8x5 monochrome grid.
        uint8[80] FONTSET = [
            0xF0,
            0x90,
            0x90,
            0x90,
            0xF0, // 0
            0x20,
            0x60,
            0x20,
            0x20,
            0x70, // 1
            0xF0,
            0x10,
            0xF0,
            0x80,
            0xF0, // 2
            0xF0,
            0x10,
            0xF0,
            0x10,
            0xF0, // 3
            0x90,
            0x90,
            0xF0,
            0x10,
            0x10, // 4
            0xF0,
            0x80,
            0xF0,
            0x10,
            0xF0, // 5
            0xF0,
            0x80,
            0xF0,
            0x90,
            0xF0, // 6
            0xF0,
            0x10,
            0x20,
            0x40,
            0x40, // 7
            0xF0,
            0x90,
            0xF0,
            0x90,
            0xF0, // 8
            0xF0,
            0x90,
            0xF0,
            0x10,
            0xF0, // 9
            0xF0,
            0x90,
            0xF0,
            0x90,
            0x90, // A
            0xE0,
            0x90,
            0xE0,
            0x90,
            0xE0, // B
            0xF0,
            0x80,
            0x80,
            0x80,
            0xF0, // C
            0xE0,
            0x90,
            0x90,
            0x90,
            0xE0, // D
            0xF0,
            0x80,
            0xF0,
            0x80,
            0xF0, // E
            0xF0,
            0x80,
            0xF0,
            0x80,
            0x80 // F
        ];
    
        struct Emulator {
            /// @notice 16-bit program counter.
            uint16 pc;
            /// @notice 4KB of RAM.
            uint8[4096] ram;
            /// @notice Display as a bitfield (8 rows of 256 bits each).
            uint256[8] screen;
            /// @notice Sixteen 8-bit general-purpose registers (V0 to VF).
            uint8[16] v_reg;
            /// @notice A 16-bit register for memory access (I register).
            uint16 i_reg;
            /// @notice Stack pointer.
            uint16 sp;
            /// @notice Stack for subroutine calls.
            uint16[16] stack;
            /// @notice Keyboard state as a 16-bit bitfield.
            uint16 keys;
            /// @notice Delay timer.
            uint8 dt;
            /// @notice Sound timer.
            uint8 st;
            /// @notice Size of the loaded program.
            uint256 program_size;
        }
    
        /// @dev Instance of the CHIP-8 emulator.
        Emulator emu;
    
        // -------------------------------------------------------------------------
        // Initialization
        // -------------------------------------------------------------------------
    
        /// @notice The starting address for programs (typically 0x200).
        uint16 constant START_ADDR = 0x200;
    
        /// @notice Constructor that initializes the emulator with the font set.
        constructor() {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        /// @notice Resets the emulator to its initial state.
        function reset() public {
            emu.pc = START_ADDR;
            for (uint256 i = 0; i < 8; i++) {
                emu.screen[i] = 0;
            }
            for (uint256 i = 0; i < NUM_REGS; i++) {
                emu.v_reg[i] = 0;
            }
            emu.i_reg = 0;
            emu.sp = 0;
            for (uint256 i = 0; i < STACK_SIZE; i++) {
                emu.stack[i] = 0;
            }
            emu.keys = 0;
            emu.dt = 0;
            emu.st = 0;
    
            // Reload font set into RAM
            for (uint256 i = 0; i < FONTSET_SIZE; i++) {
                emu.ram[i] = FONTSET[i];
            }
        }
    
        // -------------------------------------------------------------------------
        // Emulation functions
        // -------------------------------------------------------------------------
    
        /// @notice Push a value onto the stack
        function push(uint16 val) internal {
            require(emu.sp < STACK_SIZE, "Stack overflow");
            emu.stack[emu.sp] = val;
            emu.sp += 1;
        }
    
        /// @notice Pop a value from the stack
        function pop() internal returns (uint16) {
            require(emu.sp > 0, "Stack underflow");
            emu.sp -= 1;
            return emu.stack[emu.sp];
        }
    
        /// @notice CPU processing loop
        /// @dev This function is called once per tick of the CPU.
        /// Fetch the next instruction, decode and execute it.
        function tick() public {
            // Fetch
            uint16 op = fetch();
            // Decode & execute
            execute(op);
    
            _tickTimers();
        }
    
        function _tickTimers() internal {
            if (emu.dt > 0) {
                emu.dt -= 1;
            }
    
            if (emu.st > 0) {
                if (emu.st == 1) {
                    // BEEP
                }
                emu.st -= 1;
            }
        }
    
        /// @notice Fetch the next instruction
        function fetch() public returns (uint16) {
            require(emu.pc + 1 < RAM_SIZE, "Program counter out of bounds");
            uint16 higher_byte = uint16(emu.ram[emu.pc]);
            uint16 lower_byte = uint16(emu.ram[emu.pc + 1]);
            uint16 op = (higher_byte << 8) | lower_byte;
            emu.pc += 2;
            return op;
        }
    
        function run() public {
            require(emu.program_size > 0, "Program size is 0");
            for (uint256 i = 0; i < emu.program_size; i++) {
                require(emu.pc < RAM_SIZE - 1, "Program counter out of bounds");
                // Fetch the opcode
                uint16 op = fetch();
                // Execute the opcode
                execute(op);
            }
        }
    
        function execute(uint16 op) internal {
            // 0000 - Nop - NOP
            if (op == 0x0000) return;
    
            uint8 digit1 = uint8((op & 0xF000) >> 12);
            uint8 digit2 = uint8((op & 0x0F00) >> 8);
            uint8 digit3 = uint8((op & 0x00F0) >> 4);
            uint8 digit4 = uint8(op & 0x000F);
    
            //  00E0 - CLS
            if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0) {
                for (uint256 i = 0; i < 8; i++) {
                    emu.screen[i] = 0;
                }
                return;
            }
            // 00EE - RET
            else if (digit1 == 0x0 && digit2 == 0x0 && digit3 == 0xE && digit4 == 0xE) {
                emu.pc = pop();
                return;
            }
            //  1NNN - JMP NNN
            else if (digit1 == 0x1) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = nnn;
                return;
            }
            //  2NNN - CALL NNN
            else if (digit1 == 0x2) {
                uint16 nnn = op & 0x0FFF;
                push(emu.pc);
                emu.pc = nnn;
                return;
            }
            //  3NNN - SKIP VX == NN
            else if (digit1 == 0x3) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] == nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  4NNN - SKIP VX != NN
            else if (digit1 == 0x4) {
                uint8 nn = uint8(op & 0xFF);
                if (emu.v_reg[digit2] != nn) {
                    emu.pc += 2;
                }
                return;
            }
            //  5NNN - SKIP VX == VY
            else if (digit1 == 0x5 && digit4 == 0x0) {
                if (emu.v_reg[digit2] == emu.v_reg[digit3]) {
                    emu.pc += 2;
                }
                return;
            }
            //  6NNN - VX = NN
            else if (digit1 == 0x6) {
                uint8 nn = uint8(op & 0xFF);
                emu.v_reg[digit2] = nn;
                return;
            }
            //  7NNN - VX += NN
            else if (digit1 == 0x7) {
                uint8 nn = uint8(op & 0xFF);
                unchecked {
                    emu.v_reg[digit2] += nn;
                }
                return;
            }
            // 8XY0 - VX = VY
            else if (digit1 == 0x8 && digit4 == 0x0) {
                emu.v_reg[digit2] = emu.v_reg[digit3];
                return;
            }
            // 8XY1 - VX |= VY
            else if (digit1 == 0x8 && digit4 == 0x1) {
                emu.v_reg[digit2] |= emu.v_reg[digit3];
                return;
            }
            // 8XY2 - VX &= VY
            else if (digit1 == 0x8 && digit4 == 0x2) {
                emu.v_reg[digit2] &= emu.v_reg[digit3];
                return;
            }
            // 8XY3 - VX ^= VY
            else if (digit1 == 0x8 && digit4 == 0x3) {
                emu.v_reg[digit2] ^= emu.v_reg[digit3];
                return;
            }
            // 8XY4 - VX += VY (with carry)
            else if (digit1 == 0x8 && digit4 == 0x4) {
                uint8 x = digit2;
                uint8 y = digit3;
                uint16 sum = uint16(emu.v_reg[x]) + uint16(emu.v_reg[y]);
                emu.v_reg[0xF] = sum > 0xFF ? 1 : 0;
                emu.v_reg[x] = uint8(sum);
                return;
            }
            // 8XY5 - VX -= VY (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x5) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[x] >= emu.v_reg[y] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] -= emu.v_reg[y];
                }
                return;
            }
            // 8XY6 - VX >>= 1
            else if (digit1 == 0x8 && digit4 == 0x6) {
                uint8 x = digit2;
                emu.v_reg[0xF] = emu.v_reg[x] & 0x1;
                emu.v_reg[x] >>= 1;
                return;
            }
            // 8XY7 - VX = VY - VX (with borrow)
            else if (digit1 == 0x8 && digit4 == 0x7) {
                uint8 x = digit2;
                uint8 y = digit3;
                emu.v_reg[0xF] = emu.v_reg[y] >= emu.v_reg[x] ? 1 : 0;
                unchecked {
                    emu.v_reg[x] = emu.v_reg[y] - emu.v_reg[x];
                }
                return;
            }
            // 8XYE - VX <<= 1
            else if (digit1 == 0x8 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.v_reg[0xF] = (emu.v_reg[x] >> 7) & 0x1;
                emu.v_reg[x] <<= 1;
                return;
            }
            // 9XY0 - SKIP VX != VY
            else if (digit1 == 0x9 && digit4 == 0x0) {
                uint8 x = digit2;
                uint8 y = digit3;
                if (emu.v_reg[x] != emu.v_reg[y]) {
                    emu.pc += 2;
                }
                return;
            }
            // ANNN - I = NNN
            else if (digit1 == 0xA) {
                uint16 nnn = op & 0x0FFF;
                emu.i_reg = nnn;
                return;
            }
            // BNNN - PC = V0 + NNN
            else if (digit1 == 0xB) {
                uint16 nnn = op & 0x0FFF;
                emu.pc = uint16(emu.v_reg[0]) + nnn;
                return;
            }
            // CXNN - VX = rand() & NN
            else if (digit1 == 0xC) {
                uint8 x = digit2;
                uint8 nn = uint8(op & 0x00FF);
                // Pseudo-random number generation (not secure)
                uint8 rand =
                    uint8(uint256(keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 1), emu.pc))) % 256);
                emu.v_reg[x] = rand & nn;
                return;
            }
            // DXYN - DRAW
            else if (digit1 == 0xD) {
                uint8 x = emu.v_reg[digit2] % uint8(SCREEN_WIDTH);
                uint8 y = emu.v_reg[digit3] % uint8(SCREEN_HEIGHT);
                uint8 height = digit4;
                emu.v_reg[0xF] = 0; // Reset VF
    
                for (uint8 row = 0; row < height; row++) {
                    uint8 sprite_byte = emu.ram[emu.i_reg + row];
                    for (uint8 col = 0; col < 8; col++) {
                        // Get the sprite pixel (bit) at the current column
                        uint8 sprite_pixel = (sprite_byte >> (7 - col)) & 0x1;
                        uint32 screen_x = uint32((x + col) % SCREEN_WIDTH);
                        uint32 screen_y = uint32((y + row) % SCREEN_HEIGHT);
    
                        // Calculate the index in the display buffer
                        uint32 pixel_index = screen_y * SCREEN_WIDTH + screen_x; // Range: 0 to 2047
    
                        // Calculate the display array index and bit position
                        uint256 display_index = pixel_index / 256; // Index in emu.screen[]
                        uint256 bit_position = pixel_index % 256; // Bit position within emu.screen[display_index]
    
                        // Get the current pixel value from the display
                        bool pixel_before = ((emu.screen[display_index] >> (255 - bit_position)) & 0x1) != 0;
    
                        // Calculate the new pixel value using XOR (as per CHIP-8 drawing behavior)
                        bool new_pixel = pixel_before != (sprite_pixel == 1);
    
                        // Update the collision flag VF if a pixel is erased
                        if (pixel_before && !new_pixel) {
                            emu.v_reg[0xF] = 1;
                        }
    
                        // Update the display with the new pixel value
                        if (new_pixel) {
                            // Set the bit to 1
                            emu.screen[display_index] |= (1 << (255 - bit_position));
                        } else {
                            // Set the bit to 0
                            emu.screen[display_index] &= ~(1 << (255 - bit_position));
                        }
                    }
                }
                return;
            }
            // EX9E - SKIP if key[VX] pressed
            else if (digit1 == 0xE && digit3 == 0x9 && digit4 == 0xE) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if ((emu.keys & (1 << key)) != 0) {
                    emu.pc += 2;
                }
                return;
            }
            // EXA1 - SKIP if key[VX] not pressed
            else if (digit1 == 0xE && digit3 == 0xA && digit4 == 0x1) {
                uint8 x = digit2;
                uint8 key = emu.v_reg[x];
                require(key < NUM_KEYS, "Invalid key");
                if ((emu.keys & (1 << key)) == 0) {
                    emu.pc += 2;
                }
                return;
            }
            // FX07 - VX = DT
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0x7) {
                uint8 x = digit2;
                emu.v_reg[x] = emu.dt;
                return;
            }
            // FX0A - Wait for key press
            else if (digit1 == 0xF && digit3 == 0x0 && digit4 == 0xA) {
                uint8 x = digit2;
                bool key_pressed = false;
                for (uint8 i = 0; i < NUM_KEYS; i++) {
                    if ((emu.keys & (1 << i)) != 0) {
                        emu.v_reg[x] = i;
                        key_pressed = true;
                        break;
                    }
                }
                if (!key_pressed) {
                    // Repeat this opcode
                    emu.pc -= 2;
                }
                return;
            }
            // FX15 - DT = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x5) {
                uint8 x = digit2;
                emu.dt = emu.v_reg[x];
                return;
            }
            // FX18 - ST = VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0x8) {
                uint8 x = digit2;
                emu.st = emu.v_reg[x];
                return;
            }
            // FX1E - I += VX
            else if (digit1 == 0xF && digit3 == 0x1 && digit4 == 0xE) {
                uint8 x = digit2;
                emu.i_reg += uint16(emu.v_reg[x]);
                return;
            }
            // FX29 - I = location of sprite for digit VX
            else if (digit1 == 0xF && digit3 == 0x2 && digit4 == 0x9) {
                uint8 x = digit2;
                uint8 digit = emu.v_reg[x];
                emu.i_reg = uint16(digit) * 5; // Each sprite is 5 bytes
                return;
            }
            // FX33 - Store BCD representation of VX in memory locations I, I+1, and I+2
            else if (digit1 == 0xF && digit3 == 0x3 && digit4 == 0x3) {
                uint8 x = digit2;
                uint8 value = emu.v_reg[x];
                emu.ram[emu.i_reg] = value / 100;
                emu.ram[emu.i_reg + 1] = (value / 10) % 10;
                emu.ram[emu.i_reg + 2] = value % 10;
                return;
            }
            // FX55 - Store V0 to VX in memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x5 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.ram[emu.i_reg + i] = emu.v_reg[i];
                }
                return;
            }
            // FX65 - Read V0 to VX from memory starting at address I
            else if (digit1 == 0xF && digit3 == 0x6 && digit4 == 0x5) {
                uint8 x = digit2;
                for (uint8 i = 0; i <= x; i++) {
                    emu.v_reg[i] = emu.ram[emu.i_reg + i];
                }
                return;
            } else {
                revert("Opcode not implemented");
            }
        }
    
        // -------------------------------------------------------------------------
        // Frontend functions
        // -------------------------------------------------------------------------
    
        /// @notice Get display
        function getDisplay() public view returns (uint256[8] memory) {
            return emu.screen;
        }
    
        /// @notice Handle keypress event
        /// @param idx Index of the key (0-15)
        /// @param pressed Whether the key is pressed (true) or released (false)
        function keypress(uint256 idx, bool pressed) public {
            require(idx < 16, "Invalid key index");
    
            if (pressed) {
                // Set the bit at position `idx` to 1
                emu.keys |= uint16(1 << idx);
            } else {
                // Clear the bit at position `idx` to 0
                emu.keys &= ~uint16(1 << idx);
            }
        }
    
        /// @notice Load program into memory
        function load(uint8[] memory data) public {
            uint256 start = START_ADDR;
            uint256 end = START_ADDR + data.length;
            require(end <= RAM_SIZE, "Data too large to fit in RAM");
            for (uint256 i = start; i < end; i++) {
                emu.ram[i] = data[i - start];
            }
            emu.program_size = data.length;
        }
    
        // -------------------------------------------------------------------------
        // Utility functions
        // -------------------------------------------------------------------------
    
        function getPC() public view returns (uint16) {
            return emu.pc;
        }
    
        function getKeys() public view returns (uint16) {
            return emu.keys;
        }
    
        function getRAMValueAt(uint256 index) public view returns (uint8) {
            require(index < RAM_SIZE, "RAM index out of bounds");
            return emu.ram[index];
        }
    
        function getVRegister(uint256 index) public view returns (uint8) {
            require(index < NUM_REGS, "V register index out of bounds");
            return emu.v_reg[index];
        }
    
        function setVRegister(uint8 index, uint8 value) public {
            require(index < NUM_REGS, "V register index out of bounds");
            emu.v_reg[index] = value;
        }
    
        function getIRegister() public view returns (uint16) {
            return emu.i_reg;
        }
    
        function setIRegister(uint16 value) public {
            emu.i_reg = value;
        }
    
        function setRAMValueAt(uint256 index, uint8 value) public {
            require(index < RAM_SIZE, "RAM index out of bounds");
            emu.ram[index] = value;
        }
    
        function getDelayTimer() public view returns (uint8) {
            return emu.dt;
        }
    
        function setDelayTimer(uint8 value) public {
            emu.dt = value;
        }
    
        function getSoundTimer() public view returns (uint8) {
            return emu.st;
        }
    
        function setSoundTimer(uint8 value) public {
            emu.st = value;
        }
    
        function getSP() public view returns (uint16) {
            return emu.sp;
        }
    
        function getStackValue(uint256 index) public view returns (uint16) {
            require(index < STACK_SIZE, "Stack index out of bounds");
            return emu.stack[index];
        }
    
        function setStackValue(uint256 index, uint16 value) public {
            require(index < STACK_SIZE, "Stack index out of bounds");
            emu.stack[index] = value;
        }
    
        function setSP(uint16 value) public {
            emu.sp = value;
        }
    
        function setScreenPixel(uint256 index, bool value) public {
            unchecked {
                require(index < SCREEN_WIDTH * SCREEN_HEIGHT, "Index out of bounds");
                if (value) {
                    // Set the bit to 1
                    emu.screen[index >> 8] |= 1 << (index & 255);
                } else {
                    // Set the bit to 0
                    emu.screen[index >> 8] &= ~(1 << (index & 255));
                }
            }
        }
    
        function isDisplayCleared() public view returns (bool) {
            return (
                emu.screen[0] == 0 && emu.screen[1] == 0 && emu.screen[2] == 0 && emu.screen[3] == 0 && emu.screen[4] == 0
                    && emu.screen[5] == 0 && emu.screen[6] == 0 && emu.screen[7] == 0
            );
        }
    }
     
}

#[tokio::main]
async fn main() {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: cargo run path/to/game");
        return;
    }

    // Setup SDL
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();
    let window = video_subsystem
        .window("Chip-8 Emulator", WINDOW_WIDTH, WINDOW_HEIGHT)
        .position_centered()
        .opengl()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    canvas.clear();
    canvas.present();
    let mut event_pump = sdl_context.event_pump().unwrap();
    // testing anvil account
    let signer: PrivateKeySigner = PrivateKeySigner::from_str(
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    )
    .unwrap();
    let wallet = EthereumWallet::from(signer);

    let provider = ProviderBuilder::new()
        .with_recommended_fillers()
        .wallet(wallet)
        .on_http(Url::from_str("http://localhost:8545").unwrap());

    // Get node info using the Anvil API.
    let info = provider.anvil_node_info().await.unwrap();

    println!("Node info: {:#?}", info);

    let chip8 = Solchip8::deploy(&provider).await.unwrap();
    // commented out, address that deployed on sepolia
    // let address = Address::from_str("0x8494dba7A8958629fE3e55D8F7F5eAF22978a467").unwrap();
    // let chip8 = Emu::new(address, &provider);

    let mut rom = File::open(&args[1]).expect("Unable to open file");
    let mut buffer = Vec::new();

    rom.read_to_end(&mut buffer).unwrap();
    println!("Loaded ROM with {:?} bytes", buffer);
    let builder = chip8.load(buffer.to_vec());
    builder.call().await.unwrap();
    // 250ms
    let tx = builder.send().await.unwrap().get_receipt().await.unwrap();
    println!("load tx: {:?}", tx);
    let r = chip8.getRAMValueAt(U256::from(512)).call().await.unwrap();
    // Check loaded successfully
    assert_eq!(r._0, buffer[0]);

    'gameloop: loop {
        let now = std::time::Instant::now();
        for evt in event_pump.poll_iter() {
            match evt {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::Escape),
                    ..
                } => {
                    break 'gameloop;
                }
                Event::KeyDown {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), true);
                        builder.call().await.unwrap();

                        let keys = chip8.getKeys().call().await.unwrap();
                        println!("keys: {:?}", keys._0);

                        if keys._0  & (1 << k) == 0{
                            let tx = builder.send().await.unwrap();
                            println!("⭐️ key {:?} down tx: {:?}", key, tx);
                        }
                      
                    }
                }
                Event::KeyUp {
                    keycode: Some(key), ..
                } => {
                    if let Some(k) = key2btn(key) {
                        let builder = chip8.keypress(U256::from(k), false);
                        builder.call().await.unwrap();

                        let keys = chip8.getKeys().call().await.unwrap();
                        println!("keys: {:?}", keys._0);

                        if keys._0  & (1 << k) != 0{
                            let tx = builder.send().await.unwrap();
                            println!("⭐️ key {:?} up tx: {:?}", key, tx);
                        }
                    }
                }
                _ => (),
            }
        }

        // TODO: I want to have tick per frame
        // for _ in 0..TICKS_PER_FRAME {}
        let builder = chip8.tick();
        builder.call().await.unwrap();
        let tx = builder.send().await.unwrap();
        println!("tx for tick:{:?}", tx);
 

        let pc = chip8.getPC().call().await.unwrap();
        println!("PC: {:?}", pc._0);

        let keys = chip8.getKeys().call().await.unwrap();
        println!("keys: {:?}", keys._0);

        let dt = chip8.getDelayTimer().call().await.unwrap();
        println!("DT: {:?}", dt._0);
     
        draw_screen(&chip8, &mut canvas).await;

        let end = std::time::Instant::now();
        println!("⌛️ duration :{:?}", end.duration_since(now));
    }
}

async fn draw_screen<T, P, N>(emu: &Solchip8Instance<T, P, N>, canvas: &mut Canvas<Window>)
where
    T: Transport + Clone,
    P: Provider<T, N>,
    N: Network,
{
    // Clear canvas as black
    canvas.set_draw_color(Color::RGB(0, 0, 0));
    canvas.clear();

    let builder = emu.getDisplay();
    let screen_buf = builder.call().await.unwrap()._0;

    // Now set draw color to white, iterate through each point and see if it should be drawn
    canvas.set_draw_color(Color::RGB(255, 255, 255));
    for (i, pixel) in screen_buf.iter().enumerate() {
        let pixel_bytes:[u8; 32]  = pixel.to_be_bytes();
        for (j, pixel_byte) in pixel_bytes.into_iter().enumerate() {
            let pixel_bits = pixel_byte.view_bits::<Msb0>();
            for (k, pixel_bit) in pixel_bits.into_iter().enumerate() {
                if *pixel_bit {
                    let index= k + (j * 8) + (i * 256);
                    // println!("index:{:?}", index);
                    // Convert our 1D array's index into a 2D (x,y) position
                    let x = (index % SCREEN_WIDTH) as u32;
                    let y = (index / SCREEN_WIDTH) as u32;
        
                    // Draw a rectangle at (x,y), scaled up by our SCALE value
                    let rect = Rect::new((x * SCALE) as i32, (y * SCALE) as i32, SCALE, SCALE);
                    canvas.fill_rect(rect).unwrap();
                }
            }
        }
       
    }
    canvas.present();
}

/*
    Keyboard                    Chip-8
    +---+---+---+---+           +---+---+---+---+
    | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 | C |
    +---+---+---+---+           +---+---+---+---+
    | Q | W | E | R |           | 4 | 5 | 6 | D |
    +---+---+---+---+     =>    +---+---+---+---+
    | A | S | D | F |           | 7 | 8 | 9 | E |
    +---+---+---+---+           +---+---+---+---+
    | Z | X | C | V |           | A | 0 | B | F |
    +---+---+---+---+           +---+---+---+---+
*/

fn key2btn(key: Keycode) -> Option<usize> {
    match key {
        Keycode::Num1 => Some(0x1),
        Keycode::Num2 => Some(0x2),
        Keycode::Num3 => Some(0x3),
        Keycode::Num4 => Some(0xC),
        Keycode::Q => Some(0x4),
        Keycode::W => Some(0x5),
        Keycode::E => Some(0x6),
        Keycode::R => Some(0xD),
        Keycode::A => Some(0x7),
        Keycode::S => Some(0x8),
        Keycode::D => Some(0x9),
        Keycode::F => Some(0xE),
        Keycode::Z => Some(0xA),
        Keycode::X => Some(0x0),
        Keycode::C => Some(0xB),
        Keycode::V => Some(0xF),
        _ => None,
    }
}
